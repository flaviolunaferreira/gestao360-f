Relatório de arquivos do diretório: /home/flavi/projeto/gestao360-f/src/
Data de geração: 1744070367.8791633
Extensões permitidas: .html, .scss, .ts, .json


==================================================
Arquivo: index.html
==================================================

<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>Gestao360F</title>
  <base href="/">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" type="image/x-icon" href="favicon.ico">
  <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@300;400;500&display=swap" rel="stylesheet">
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet">
</head>
<body class="mat-typography">
  <app-root></app-root>
</body>
</html>



==================================================
Arquivo: main.ts
==================================================

import { bootstrapApplication } from '@angular/platform-browser';
import { AppComponent } from './app/app.component';
import { routes } from './app/app.routes';
import { provideRouter } from '@angular/router';
import { provideHttpClient } from '@angular/common/http'; // Adicione esta importação

bootstrapApplication(AppComponent, {
  providers: [
    provideRouter(routes),
    provideHttpClient() // Adicione este provider
  ]
}).catch(err => console.error(err));



==================================================
Arquivo: styles.scss
==================================================

:root {
  --background-color: #242323;
  --sidebar-color: #272727;
  --text-color: #dfdfdf;
  --border-color: #3c3c3c;
  --scrollbar-color: #3c3c3c;
  --scrollbar-thumb-color: #1d1d1d;
  --header-color: #333333;
  --footer-color: #333333;
  --link-color: #3794ff;
  --primary-color: #152d3d;
  // Cores inspiradas no Visual Studio Code
  --background-dark: #1e1e1e; // Fundo escuro do VS Code
  --primary-blue: #007acc; // Azul do VS Code
  --accent-orange: #d19a66; // Laranja para detalhes
  --text-light: #d4d4d4; // Texto claro
  --input-bg: #252526; // Fundo dos inputs
  --border-color: #3c3c3c; // Bordas
  --error-color: #f48771; // Cor para mensagens de erro
}

* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
}



==================================================
Arquivo: app/JwtInterceptor.ts
==================================================

import { Injectable, inject } from '@angular/core';
import {
  HttpRequest,
  HttpHandler,
  HttpEvent,
  HttpInterceptor
} from '@angular/common/http';
import { Observable } from 'rxjs';
import { AuthService } from './service/login/AuthService.service';

@Injectable()
export class JwtInterceptor implements HttpInterceptor {
  private authService = inject(AuthService);

  intercept(request: HttpRequest<unknown>, next: HttpHandler): Observable<HttpEvent<unknown>> {
    const token = this.authService.getToken();
    
    if (token) {
      request = request.clone({
        setHeaders: { Authorization: `Bearer ${token}` }
      });
    }

    return next.handle(request);
  }
}


==================================================
Arquivo: app/app.component.html
==================================================

<div class="main">
  <div class="toolbar">
    <app-toolbar></app-toolbar>
  </div>
  <div class="opcoes">
    <app-icon-bar (sendOptionsToSidebar)="sidebar.options = $event"></app-icon-bar>
    <app-sidebar #sidebar></app-sidebar>
    <div class="conteudo">
      <div class="page">
        <router-outlet></router-outlet>
      </div>
    </div>
  </div>
  <div class="footer">
    <app-footer></app-footer>
  </div>
</div>



==================================================
Arquivo: app/app.component.scss
==================================================

.main {
  display: flex;
  flex-direction: column;
  height: 100vh;
  width: 100%;
  background-color: var(--background-color);
  color: var(--text-color);
  font-family: 'Roboto', sans-serif;

  .toolbar {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    z-index: 1000;
  }

  .opcoes {
    display: flex;
    flex: 1;
    margin-top: 64px; /* Altura da toolbar */
    overflow: hidden;

    .icon-bar {
      width: 50px; /* Largura da barra de ícones */
      background-color: var(--sidebar-color);
    }

    .sidebar {
      width: 250px; /* Largura da sidebar */
      background-color: var(--sidebar-color);
      transition: transform 0.3s ease;
      transform: translateX(0);
    }

    .sidebar.hidden {
      transform: translateX(-100%);
    }

    .conteudo {
      flex: 1;
      display: flex;
      justify-content: center;
      padding: 1rem;
      overflow-y: auto;
      transition: margin-left 0.3s ease;
      .page {
        width: 100%;
        height: 100%;
      }
    }

    .conteudo.full-width {
      margin-left: 0;
    }

    .conteudo.with-sidebar {
      margin-left: 250px; /* Largura da sidebar */
    }
  }

  footer {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 2rem;
    z-index: 1000;
  }
}



==================================================
Arquivo: app/app.component.spec.ts
==================================================




==================================================
Arquivo: app/app.component.ts
==================================================

import { Component } from '@angular/core';
import { MatSidenavModule } from '@angular/material/sidenav';
import { RouterModule } from '@angular/router';
import { FooterComponent } from './components/footer/footer.component';
import { SidebarComponent } from './components/sidebar/sidebar.component';
import { ToolbarComponent } from './components/toolbar/toolbar.component';
import { IconBarComponent } from './components/icon-bar/icon-bar.component';
import { CommonModule } from '@angular/common';
import { HttpClientModule } from '@angular/common/http';

@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.scss'],
  standalone: true,
  imports: [
    CommonModule,
    MatSidenavModule,
    RouterModule,
    FooterComponent,
    SidebarComponent,
    ToolbarComponent,
    IconBarComponent,
    HttpClientModule
  ]
})
export class AppComponent {
  isSidebarOpen = false;
  sidebarOptions: string[] = [];

  toggleSidebar(options: string[]) {
    if (this.isSidebarOpen && this.sidebarOptions === options) {
      this.isSidebarOpen = false;
    } else {
      this.isSidebarOpen = true;
      this.sidebarOptions = options;
    }
  }
}



==================================================
Arquivo: app/app.config.ts
==================================================

import { ApplicationConfig, provideZoneChangeDetection } from '@angular/core';
import { provideRouter } from '@angular/router';

import { routes } from './app.routes';
import { HTTP_INTERCEPTORS } from '@angular/common/http'; // Adicionando a importação correta
import { JwtInterceptor } from './JwtInterceptor'; // Adicionando a importação correta
export const appConfig: ApplicationConfig = {
  providers: [
    provideZoneChangeDetection({ eventCoalescing: true }),
    provideRouter(routes),
    { provide: HTTP_INTERCEPTORS, useClass: JwtInterceptor, multi: true }
  ]
};



==================================================
Arquivo: app/app.routes.ts
==================================================

import { Routes } from '@angular/router';
import { LoginComponent } from './pages/login/login.component';
import { ModuloListComponent } from './pages/cadastros/modulo/modulo-list.component';
import { EmpresaClienteComponent } from './pages/cadastros/empresa-cliente/empresa-cliente.component';
import { BancoComponent } from './pages/cadastros/banco/banco.component';
import { CartaoComponent } from './pages/cadastros/cartao/cartao.component';
import { ClienteComponent } from './pages/cadastros/cliente/cliente.component';
import { FornecedorComponent } from './pages/cadastros/fornecedor/fornecedor.component';
import { FuncionarioComponent } from './pages/cadastros/funcionario/funcionario.component';
import { LojaComponent } from './pages/cadastros/loja/loja.component';
import { ProdutoComponent } from './pages/cadastros/produto/produto.component';
import { UsuarioComponent } from './pages/cadastros/usuario/usuario.component';
import { ContaComponent } from './pages/cadastros/conta/conta.component';
import { PlanoListComponent } from './pages/cadastros/plano/plano-list.component';

export const routes: Routes = [
  // Rotas de cadastro (todas públicas inicialmente)
  { path: 'banco', component: BancoComponent },
  { path: 'cartao', component: CartaoComponent },
  { path: 'cliente', component: ClienteComponent },
  { path: 'conta', component: ContaComponent },
  { path: 'empresa-cliente', component: EmpresaClienteComponent },
  { path: 'fornecedor', component: FornecedorComponent },
  { path: 'funcionario', component: FuncionarioComponent },
  { path: 'loja', component: LojaComponent },
  { path: 'modulo', component: ModuloListComponent },
  { path: 'plano', component: PlanoListComponent },
  { path: 'produto', component: ProdutoComponent },
  { path: 'usuario', component: UsuarioComponent },
  
  // Rota de login (pública)
  { path: 'login', component: LoginComponent },
  
  // Redirecionamentos
  { path: '', redirectTo: 'banco', pathMatch: 'full' }, // Rota padrão
  { path: '**', redirectTo: 'banco' } // Rota curinga
];


==================================================
Arquivo: app/auth.guard.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { CanActivateFn, Router } from '@angular/router';
import { AuthService } from './service/login/AuthService.service';

export const authGuard: CanActivateFn = () => {
  const authService = inject(AuthService);
  const router = inject(Router);

  if (authService.getToken()) {
    return true;
  } else {
    router.navigate(['/login']);
    return false;
  }
};


==================================================
Arquivo: app/interface/Field-config.model.ts
==================================================

export interface FieldConfig {
    name: string;
    label: string;
    type: 'input' | 'dropdown' | 'checkbox' | 'date' | 'textarea';
    dataType: 'string' | 'number' | 'boolean' | 'enum' | 'date';
    required?: boolean;
    minLength?: number;
    maxLength?: number;
    minValue?: number;
    maxValue?: number;
    pattern?: string;
    options?: string[]; // Para dropdown
    showInTable?: boolean;
    showInForm?: boolean;
    filterable?: boolean;
    defaultValue?: any;
    mask?: string; // Para input com máscara;
  }
  
  export interface ActionConfig {
    view?: boolean;
    edit?: boolean;
    delete?: boolean;
  }
  
  export interface DynamicTableConfig {
    fields: FieldConfig[];
    actions?: ActionConfig;
    title?: string; // Adicionando título opcional
  }


==================================================
Arquivo: app/interface/Login.ts
==================================================

export interface LoginRequest {
  email: string;
  password: string;
}

export interface LoginResponse {
  token: string;
  email: string;
  tipo: string;
  empresaId: number;
  modulosLiberados: string[];
}


==================================================
Arquivo: app/interface/ToolBarOption.ts
==================================================

interface ToolbarOption {
    icon: string;
    text: string;
    action: () => void;
  }


==================================================
Arquivo: app/interface/cadastro/Banco.ts
==================================================

export interface Banco {
    id: string;
    codigo: string;
    nome: string;
    ispb: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateBancoDTO {
    codigo: string;
    nome: string;
    ispb: string;
  }
  
  export interface UpdateBancoDTO extends Partial<CreateBancoDTO> {}


==================================================
Arquivo: app/interface/cadastro/Cartao.ts
==================================================

export interface Cartao {
    id: string;
    numero: string;
    bandeira: string;
    tipo: 'CREDITO' | 'DEBITO';
    dataValidade: Date;
    titular: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateCartaoDTO {
    numero: string;
    bandeira: string;
    tipo: 'CREDITO' | 'DEBITO';
    dataValidade: Date;
    titular: string;
  }
  
  export interface UpdateCartaoDTO extends Partial<CreateCartaoDTO> {}


==================================================
Arquivo: app/interface/cadastro/Cliente.ts
==================================================

export interface Cliente {
    id: string;
    nome: string;
    cpfCnpj: string;
    email: string;
    telefone: string;
    endereco: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateClienteDTO {
    nome: string;
    cpfCnpj: string;
    email: string;
    telefone: string;
    endereco: string;
  }
  
  export interface UpdateClienteDTO extends Partial<CreateClienteDTO> {}


==================================================
Arquivo: app/interface/cadastro/Fornecedor.ts
==================================================

export interface Fornecedor {
    id: string;
    razaoSocial: string;
    cnpj: string;
    email: string;
    telefone: string;
    endereco: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateFornecedorDTO {
    razaoSocial: string;
    cnpj: string;
    email: string;
    telefone: string;
    endereco: string;
  }
  
  export interface UpdateFornecedorDTO extends Partial<CreateFornecedorDTO> {}


==================================================
Arquivo: app/interface/cadastro/Funcionario.ts
==================================================

export interface Funcionario {
    id: string;
    nome: string;
    cpf: string;
    email: string;
    telefone: string;
    cargo: string;
    dataAdmissao: Date;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateFuncionarioDTO {
    nome: string;
    cpf: string;
    email: string;
    telefone: string;
    cargo: string;
    dataAdmissao: Date;
  }
  
  export interface UpdateFuncionarioDTO extends Partial<CreateFuncionarioDTO> {}


==================================================
Arquivo: app/interface/cadastro/Loja.ts
==================================================

export interface Loja {
    id: string;
    nome: string;
    cnpj: string;
    email: string;
    telefone: string;
    endereco: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateLojaDTO {
    nome: string;
    cnpj: string;
    email: string;
    telefone: string;
    endereco: string;
  }
  
  export interface UpdateLojaDTO extends Partial<CreateLojaDTO> {}


==================================================
Arquivo: app/interface/cadastro/Modulo.ts
==================================================

export interface Modulo {
  id: number;
  nome: string;
  percentualCusto: number;
}

export interface CreateModuloDTO {
  nome: string;
  percentualCusto: number;
}

export interface UpdateModuloDTO extends Partial<CreateModuloDTO> {}



==================================================
Arquivo: app/interface/cadastro/Plano.ts
==================================================

import { Modulo } from "./Modulo";

export interface Plano {
  id: number;
  nome: string;
  precoBasePorLoja: number;
  gratuito: boolean;
  tempoDuracaoEmMeses?: number | null;
  modulos: Modulo[];
}

export interface CreatePlanoDTO {
  nome: string;
  precoBasePorLoja: number;
  gratuito: boolean;
  tempoDuracaoEmMeses?: number | null;
  modulosIds: number[];
}

export interface UpdatePlanoDTO extends Partial<CreatePlanoDTO> {}



==================================================
Arquivo: app/interface/cadastro/Produto.ts
==================================================

export interface Produto {
    id: string;
    nome: string;
    codigo: string;
    preco: number;
    estoque: number;
    descricao?: string;
    dataCriacao?: Date;
    dataAtualizacao?: Date;
  }
  
  export interface CreateProdutoDTO {
    nome: string;
    codigo: string;
    preco: number;
    estoque: number;
    descricao?: string;
  }
  
  export interface UpdateProdutoDTO extends Partial<CreateProdutoDTO> {}


==================================================
Arquivo: app/service/Message.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { MessageService } from './Message.service';

describe('Service: Message', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [MessageService]
    });
  });

  it('should ...', inject([MessageService], (service: MessageService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/Message.service.ts
==================================================

// src/app/shared/services/message.service.ts
import { inject, Injectable } from '@angular/core';
import { MatSnackBar } from '@angular/material/snack-bar';

@Injectable({ providedIn: 'root' })
export class MessageService {
  private readonly snackBar = inject(MatSnackBar);

  success(message: string): void {
    this.show(message, 'success-snackbar');
  }

  error(message: string): void {
    this.show(message, 'error-snackbar');
  }

  private show(message: string, panelClass: string): void {
    this.snackBar.open(message, 'Fechar', {
      duration: 5000,
      panelClass: [panelClass],
      horizontalPosition: 'right',
      verticalPosition: 'top'
    });
  }
}



==================================================
Arquivo: app/service/login/AuthService.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { AuthServiceService } from './AuthService.service';

describe('Service: AuthService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [AuthServiceService]
    });
  });

  it('should ...', inject([AuthServiceService], (service: AuthServiceService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/login/AuthService.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Router } from '@angular/router';
import { Observable, tap } from 'rxjs';
import { LoginRequest, LoginResponse } from '../../interface/Login';

@Injectable({ providedIn: 'root' })
export class AuthService {
  private http = inject(HttpClient);
  private router = inject(Router);
  private readonly API_URL = 'http://localhost:8080/api/auth';

  login(credentials: LoginRequest): Observable<LoginResponse> {
    return this.http.post<LoginResponse>(`${this.API_URL}/login`, credentials).pipe(
      tap(response => this.storeAuthData(response))
    );
  }

  private storeAuthData(response: LoginResponse): void {
    localStorage.setItem('token', response.token);
    localStorage.setItem('userData', JSON.stringify({
      email: response.email,
      tipo: response.tipo,
      empresaId: response.empresaId,
      modulos: response.modulosLiberados
    }));
  }

  getToken(): string | null {
    return localStorage.getItem('token');
  }

  logout(): void {
    localStorage.clear();
    this.router.navigate(['/login']);
  }
}


==================================================
Arquivo: app/service/cadastro/Banco.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { BancoService } from './Banco.service';

describe('Service: Banco', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [BancoService]
    });
  });

  it('should ...', inject([BancoService], (service: BancoService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/Banco.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Banco, CreateBancoDTO, UpdateBancoDTO } from '../../interface/cadastro/Banco'
import { MessageService } from '../Message.service'
@Injectable({ providedIn: 'root' })
export class BancoService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/bancos';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    
    if (error.error instanceof ErrorEvent) {
      // Erro do lado do cliente
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      // Erro do lado do servidor
      errorMessage = error.error?.message || error.message;
    }
    
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Banco[]> {
    return this.http.get<Banco[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Banco> {
    return this.http.get<Banco>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(banco: CreateBancoDTO): Observable<Banco> {
    return this.http.post<Banco>(this.apiUrl, banco).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, banco: UpdateBancoDTO): Observable<Banco> {
    return this.http.put<Banco>(`${this.apiUrl}/${id}`, banco).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/empresa/EmpresaService.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { EmpresaServiceService } from './EmpresaService.service';

describe('Service: EmpresaService', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [EmpresaServiceService]
    });
  });

  it('should ...', inject([EmpresaServiceService], (service: EmpresaServiceService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/empresa/EmpresaService.service.ts
==================================================

import { HttpClient } from '@angular/common/http';
import { inject, Injectable } from '@angular/core';
import { MessageService } from '../../Message.service';
import { FieldConfig } from '../../../interface/Field-config.model';
import { catchError, Observable, throwError } from 'rxjs';

@Injectable({
  providedIn: 'root'
})
export class EmpresaServiceService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = `http://localhost:8080/empresas`;

  getConfig(): Observable<FieldConfig[]> {
    return this.http.get<FieldConfig[]>(`${this.apiUrl}/options`).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao carregar configuração');
        return throwError(() => error);
      })
    );
  }

  getAll(): Observable<any[]> {
    return this.http.get<any[]>(this.apiUrl).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao carregar empresas');
        return throwError(() => error);
      })
    );
  }

  create(data: any): Observable<any> {
    return this.http.post(this.apiUrl, data).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao criar empresa');
        return throwError(() => error);
      })
    );
  }

  update(id: number, data: any): Observable<any> {
    return this.http.put(`${this.apiUrl}/${id}`, data).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao atualizar empresa');
        return throwError(() => error);
      })
    );
  }

  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao excluir empresa');
        return throwError(() => error);
      })
    );
  }
}


==================================================
Arquivo: app/service/cadastro/Cartao/Cartao.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { CartaoService } from './Cartao.service';

describe('Service: Cartao', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [CartaoService]
    });
  });

  it('should ...', inject([CartaoService], (service: CartaoService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/Cartao/Cartao.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Cartao, CreateCartaoDTO, UpdateCartaoDTO } from '../../../interface/cadastro/Cartao';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class CartaoService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/cartoes';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Cartao[]> {
    return this.http.get<Cartao[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Cartao> {
    return this.http.get<Cartao>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(cartao: CreateCartaoDTO): Observable<Cartao> {
    return this.http.post<Cartao>(this.apiUrl, cartao).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, cartao: UpdateCartaoDTO): Observable<Cartao> {
    return this.http.put<Cartao>(`${this.apiUrl}/${id}`, cartao).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/Cliente/Cliente.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { ClienteService } from './Cliente.service';

describe('Service: Cliente', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [ClienteService]
    });
  });

  it('should ...', inject([ClienteService], (service: ClienteService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/Cliente/Cliente.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Cliente, CreateClienteDTO, UpdateClienteDTO } from '../../../interface/cadastro/Cliente';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class ClienteService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/clientes';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Cliente[]> {
    return this.http.get<Cliente[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Cliente> {
    return this.http.get<Cliente>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(cliente: CreateClienteDTO): Observable<Cliente> {
    return this.http.post<Cliente>(this.apiUrl, cliente).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, cliente: UpdateClienteDTO): Observable<Cliente> {
    return this.http.put<Cliente>(`${this.apiUrl}/${id}`, cliente).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/Funcionario/Funcionario.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { FuncionarioService } from './Funcionario.service';

describe('Service: Funcionario', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [FuncionarioService]
    });
  });

  it('should ...', inject([FuncionarioService], (service: FuncionarioService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/Funcionario/Funcionario.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Funcionario, CreateFuncionarioDTO, UpdateFuncionarioDTO } from '../../../interface/cadastro/Funcionario';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class FuncionarioService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/funcionarios';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Funcionario[]> {
    return this.http.get<Funcionario[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Funcionario> {
    return this.http.get<Funcionario>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(funcionario: CreateFuncionarioDTO): Observable<Funcionario> {
    return this.http.post<Funcionario>(this.apiUrl, funcionario).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, funcionario: UpdateFuncionarioDTO): Observable<Funcionario> {
    return this.http.put<Funcionario>(`${this.apiUrl}/${id}`, funcionario).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/Fornecedor/Fornecedor.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { FornecedorService } from './Fornecedor.service';

describe('Service: Fornecedor', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [FornecedorService]
    });
  });

  it('should ...', inject([FornecedorService], (service: FornecedorService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/Fornecedor/Fornecedor.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Fornecedor, CreateFornecedorDTO, UpdateFornecedorDTO } from '../../../interface/cadastro/Fornecedor';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class FornecedorService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/fornecedores';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Fornecedor[]> {
    return this.http.get<Fornecedor[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Fornecedor> {
    return this.http.get<Fornecedor>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(fornecedor: CreateFornecedorDTO): Observable<Fornecedor> {
    return this.http.post<Fornecedor>(this.apiUrl, fornecedor).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, fornecedor: UpdateFornecedorDTO): Observable<Fornecedor> {
    return this.http.put<Fornecedor>(`${this.apiUrl}/${id}`, fornecedor).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/modulo/Modulo.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed,  inject } from '@angular/core/testing';
import { ModuloService } from './Modulo.service';

describe('Service: Modulo', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [ModuloService]
    });
  });

  it('should ...', inject([ModuloService], (service: ModuloService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/modulo/Modulo.service.ts
==================================================

// src/app/features/modulos/services/modulo.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpHeaders } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Modulo, CreateModuloDTO, UpdateModuloDTO } from '../../../interface/cadastro/Modulo';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class ModuloService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = `${"http://localhost:8080"}/modulos`;

  /**
   * Obtém o token de autenticação
   */
  private getAuthHeaders(): HttpHeaders {
    const token = localStorage.getItem('token');
    console.log('Token sendo enviado:', token); // Adicione este log
    
    if (!token) {
      this.messageService.error('Token não encontrado');
      // Redirecionar para login ou lidar com a ausência do token
    }
    
    return new HttpHeaders({
      'Authorization': `Bearer ${token}`,
      'Content-Type': 'application/json'
    });
  }
  /**
   * Obtém todos os módulos
   */
  getAll(): Observable<Modulo[]> {
    return this.http.get<Modulo[]>(this.apiUrl, { headers: this.getAuthHeaders() }).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao carregar módulos');
        return throwError(() => error);
      })
    );
  }

  /**
   * Obtém um módulo por ID
   */
  getById(id: number): Observable<Modulo> {
    return this.http.get<Modulo>(`${this.apiUrl}/${id}`, { headers: this.getAuthHeaders() }).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao carregar módulo ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Cria um novo módulo
   */
  create(modulo: CreateModuloDTO): Observable<Modulo> {
    return this.http.post<Modulo>(this.apiUrl, modulo, { headers: this.getAuthHeaders() }).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao criar módulo');
        return throwError(() => error);
      })
    );
  }

  /**
   * Atualiza um módulo existente
   */
  update(id: number, modulo: UpdateModuloDTO): Observable<Modulo> {
    return this.http.put<Modulo>(`${this.apiUrl}/${id}`, modulo, { headers: this.getAuthHeaders() }).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao atualizar módulo ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Remove um módulo
   */
  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`, { headers: this.getAuthHeaders() }).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao remover módulo ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Busca módulos por nome (para autocomplete)
   */
  searchByName(term: string): Observable<Modulo[]> {
    return this.http.get<Modulo[]>(`${this.apiUrl}/search`, {
      headers: this.getAuthHeaders(),
      params: { nome: term }
    }).pipe(
      catchError((error) => {
        console.error('Erro na busca:', error);
        return throwError(() => error);
      })
    );
  }
}



==================================================
Arquivo: app/service/cadastro/plano/Plano.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, inject } from '@angular/core/testing';
import { PlanoService } from './Plano.service';

describe('Service: Plano', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [PlanoService]
    });
  });

  it('should ...', inject([PlanoService], (service: PlanoService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/plano/Plano.service.ts
==================================================

// src/app/features/planos/services/plano.service.ts
import { Injectable, inject } from '@angular/core';
import { HttpClient } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Plano, CreatePlanoDTO, UpdatePlanoDTO } from '../../../interface/cadastro/Plano';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class PlanoService {
  getModulosDisponiveis(): any[] | PromiseLike<any[]> {
    throw new Error('Method not implemented.');
  }
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = `${"http:localhost:"}/planos`;

  /**
   * Obtém todos os planos
   */
  getAll(): Observable<Plano[]> {
    return this.http.get<Plano[]>(this.apiUrl).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao carregar planos');
        return throwError(() => error);
      })
    );
  }

  /**
   * Obtém um plano por ID
   */
  getById(id: number): Observable<Plano> {
    return this.http.get<Plano>(`${this.apiUrl}/${id}`).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao carregar plano ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Cria um novo plano
   */
  create(plano: CreatePlanoDTO): Observable<Plano> {
    return this.http.post<Plano>(this.apiUrl, plano).pipe(
      catchError((error) => {
        this.messageService.error('Erro ao criar plano');
        return throwError(() => error);
      })
    );
  }

  /**
   * Atualiza um plano existente
   */
  update(id: number, plano: UpdatePlanoDTO): Observable<Plano> {
    return this.http.put<Plano>(`${this.apiUrl}/${id}`, plano).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao atualizar plano ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Remove um plano
   */
  delete(id: number): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao remover plano ${id}`);
        return throwError(() => error);
      })
    );
  }

  /**
   * Ativa/desativa um plano
   */
  toggleStatus(id: number): Observable<Plano> {
    return this.http.patch<Plano>(`${this.apiUrl}/${id}/toggle-status`, {}).pipe(
      catchError((error) => {
        this.messageService.error(`Erro ao alterar status do plano ${id}`);
        return throwError(() => error);
      })
    );
  }
}



==================================================
Arquivo: app/service/cadastro/produto/Produto.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { ProdutoService } from './Produto.service';

describe('Service: Produto', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [ProdutoService]
    });
  });

  it('should ...', inject([ProdutoService], (service: ProdutoService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/produto/Produto.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Produto, CreateProdutoDTO, UpdateProdutoDTO } from '../../../interface/cadastro/Produto';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class ProdutoService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/produtos';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Produto[]> {
    return this.http.get<Produto[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Produto> {
    return this.http.get<Produto>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(produto: CreateProdutoDTO): Observable<Produto> {
    return this.http.post<Produto>(this.apiUrl, produto).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, produto: UpdateProdutoDTO): Observable<Produto> {
    return this.http.put<Produto>(`${this.apiUrl}/${id}`, produto).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/service/cadastro/loja/Loja.service.spec.ts
==================================================

/* tslint:disable:no-unused-variable */

import { TestBed, async, inject } from '@angular/core/testing';
import { LojaService } from './Loja.service';

describe('Service: Loja', () => {
  beforeEach(() => {
    TestBed.configureTestingModule({
      providers: [LojaService]
    });
  });

  it('should ...', inject([LojaService], (service: LojaService) => {
    expect(service).toBeTruthy();
  }));
});



==================================================
Arquivo: app/service/cadastro/loja/Loja.service.ts
==================================================

import { Injectable, inject } from '@angular/core';
import { HttpClient, HttpErrorResponse } from '@angular/common/http';
import { Observable, catchError, throwError } from 'rxjs';
import { Loja, CreateLojaDTO, UpdateLojaDTO } from '../../../interface/cadastro/Loja';
import { MessageService } from '../../Message.service';

@Injectable({ providedIn: 'root' })
export class LojaService {
  private readonly http = inject(HttpClient);
  private readonly messageService = inject(MessageService);
  private readonly apiUrl = 'http://localhost:8080/api/lojas';

  private handleError(error: HttpErrorResponse) {
    let errorMessage = 'Ocorreu um erro desconhecido';
    if (error.error instanceof ErrorEvent) {
      errorMessage = `Erro: ${error.error.message}`;
    } else {
      errorMessage = error.error?.message || error.message;
    }
    this.messageService.error(errorMessage);
    return throwError(() => new Error(errorMessage));
  }

  getAll(): Observable<Loja[]> {
    return this.http.get<Loja[]>(this.apiUrl).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  getById(id: string): Observable<Loja> {
    return this.http.get<Loja>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  create(loja: CreateLojaDTO): Observable<Loja> {
    return this.http.post<Loja>(this.apiUrl, loja).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  update(id: string, loja: UpdateLojaDTO): Observable<Loja> {
    return this.http.put<Loja>(`${this.apiUrl}/${id}`, loja).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }

  delete(id: string): Observable<void> {
    return this.http.delete<void>(`${this.apiUrl}/${id}`).pipe(
      catchError((error: HttpErrorResponse) => this.handleError(error))
    );
  }
}


==================================================
Arquivo: app/components/search-toolbar/search-toolbar.component.html
==================================================

<div class="toolbar">
  <mat-form-field appearance="outline" class="search-field">
    <mat-label>Pesquisar</mat-label>
    <input matInput (input)="onSearchChange($event)" placeholder="Filtrar...">
    <mat-icon matSuffix>search</mat-icon>
  </mat-form-field>

  <button mat-flat-button color="primary" (click)="addClick.emit()">
    <mat-icon>add</mat-icon> Novo
  </button>
</div>



==================================================
Arquivo: app/components/search-toolbar/search-toolbar.component.scss
==================================================




==================================================
Arquivo: app/components/search-toolbar/search-toolbar.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SearchToolbarComponent } from './search-toolbar.component';

describe('SearchToolbarComponent', () => {
  let component: SearchToolbarComponent;
  let fixture: ComponentFixture<SearchToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SearchToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SearchToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/search-toolbar/search-toolbar.component.ts
==================================================

import { Component, Output, EventEmitter } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatInputModule } from '@angular/material/input';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';

@Component({
  selector: 'app-search-toolbar',
  standalone: true,
  imports: [CommonModule, MatFormFieldModule, MatInputModule, MatIconModule, MatButtonModule],
  templateUrl: './search-toolbar.component.html',
  styleUrls: ['./search-toolbar.component.scss']
})
export class SearchToolbarComponent {
  @Output() searchChange = new EventEmitter<string>();
  @Output() addClick = new EventEmitter<void>();

  onSearchChange(event: Event) {
    const value = (event.target as HTMLInputElement).value;
    this.searchChange.emit(value);
  }
}



==================================================
Arquivo: app/components/page-container/page-container.component.html
==================================================

<mat-card>
  @if (title) {
    <mat-card-header>
      <mat-card-title>{{ title }}</mat-card-title>
    </mat-card-header>
  }

  <mat-card-content>
    <ng-content></ng-content>
  </mat-card-content>
</mat-card>



==================================================
Arquivo: app/components/page-container/page-container.component.scss
==================================================




==================================================
Arquivo: app/components/page-container/page-container.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PageContainerComponent } from './page-container.component';

describe('PageContainerComponent', () => {
  let component: PageContainerComponent;
  let fixture: ComponentFixture<PageContainerComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PageContainerComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(PageContainerComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/page-container/page-container.component.ts
==================================================

import { Component, Input } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatCardModule } from '@angular/material/card';

@Component({
  selector: 'app-page-container',
  standalone: true,
  imports: [CommonModule, MatCardModule],
  templateUrl: './page-container.component.html',
  styleUrls: ['./page-container.component.scss']
})
export class PageContainerComponent {
  @Input() title = '';
  @Input() loading = false;
}



==================================================
Arquivo: app/components/data-table/data-table.component.html
==================================================

@if (loading) {
  <mat-progress-bar mode="indeterminate"></mat-progress-bar>
}

<div class="table-container">
  <table mat-table [dataSource]="dataSource">
    @for (column of columns; track column.key) {
      <ng-container [matColumnDef]="column.key">
        <th mat-header-cell *matHeaderCellDef>{{ column.header }}</th>
        <td mat-cell *matCellDef="let item">
          @switch (column.type) {
            @case ('currency') {
              R$ {{ item[column.key] | number:'1.2-2' }}
            }
            @case ('boolean') {
              <mat-icon [color]="item[column.key] ? 'primary' : 'warn'">
                {{ item[column.key] ? 'check_circle' : 'cancel' }}
              </mat-icon>
            }
            @case ('date') {
              {{ item[column.key] | date:'dd/MM/yyyy' }}
            }
            @default {
              {{ item[column.key] }}
            }
          }
        </td>
      </ng-container>
    }

    @if (showActions) {
      <ng-container matColumnDef="actions">
        <th mat-header-cell *matHeaderCellDef>Ações</th>
        <td mat-cell *matCellDef="let item">
          <button mat-icon-button (click)="edit.emit(item)">
            <mat-icon>edit</mat-icon>
          </button>
          <button mat-icon-button color="warn" (click)="delete.emit(item)">
            <mat-icon>delete</mat-icon>
          </button>
        </td>
      </ng-container>
    }

    <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
    <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
  </table>
</div>



==================================================
Arquivo: app/components/data-table/data-table.component.scss
==================================================




==================================================
Arquivo: app/components/data-table/data-table.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { DataTableComponent } from './data-table.component';

describe('DataTableComponent', () => {
  let component: DataTableComponent;
  let fixture: ComponentFixture<DataTableComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [DataTableComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(DataTableComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/data-table/data-table.component.ts
==================================================

import { Component, Input, Output, EventEmitter, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatTableModule } from '@angular/material/table';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatProgressBarModule } from '@angular/material/progress-bar';

@Component({
  selector: 'app-data-table',
  standalone: true,
  imports: [CommonModule, MatTableModule, MatIconModule, MatButtonModule, MatProgressBarModule],
  templateUrl: './data-table.component.html',
  styleUrls: ['./data-table.component.scss']
})
export class DataTableComponent {
  @Input() dataSource: any[] = [];
  @Input() columns: TableColumn[] = [];
  @Input() loading = false;
  @Input() showActions = true;

  @Output() edit = new EventEmitter<any>();
  @Output() delete = new EventEmitter<any>();

  get displayedColumns(): string[] {
    return this.columns.map(c => c.key).concat(this.showActions ? ['actions'] : []);
  }
}

export interface TableColumn {
  key: string;
  header: string;
  type?: 'text' | 'number' | 'currency' | 'boolean' | 'date';
}



==================================================
Arquivo: app/components/dynamic-crud/dynamic-crud.component.html
==================================================

<div class="crud-container">
  <!-- Spinner durante o carregamento -->
  <div *ngIf="isLoading" class="loading-overlay">
    <div class="spinner"></div>
    <p>Carregando dados...</p>
  </div>

  <!-- Mensagem de erro -->
  <div *ngIf="error" class="error-message">
    {{ error }}
  </div>

  <div class="form-header">
    <h2>{{ isEditMode ? 'Editar Registro ' + config?.title: 'Novo Registro ' + config?.title }}</h2>
  </div>

  <!-- Conteúdo principal -->
  <div *ngIf="config" class="content-container">
    <!-- Formulário de Cadastro/Edição -->
    <form [formGroup]="form" (ngSubmit)="onSubmit()" class="form-container">
     
      <div *ngFor="let field of config.fields" 
      class="form-field"
      [class]="getFieldSizeClass(field)">

        <label [for]="field.name">{{ field.label }}</label>
        
        <!-- Input Text -->
        <input *ngIf="field.type === 'input' && field.dataType === 'string'" 
               [id]="field.name" type="text" [formControlName]="field.name">
               
        <!-- Input Number -->
        <input *ngIf="field.type === 'input' && field.dataType === 'number'" 
               [id]="field.name" type="number" [formControlName]="field.name">
               
        <!-- Checkbox -->
        <input *ngIf="field.type === 'checkbox'" 
               [id]="field.name" type="checkbox" [formControlName]="field.name">
               
        <!-- Date -->
        <input *ngIf="field.type === 'date'" 
               [id]="field.name" type="date" [formControlName]="field.name">
               
        <!-- Textarea -->
        <textarea *ngIf="field.type === 'textarea'" 
                  [id]="field.name" [formControlName]="field.name"></textarea>
                  
        <!-- Dropdown -->
        <select *ngIf="field.type === 'dropdown'" [formControlName]="field.name">
          <option *ngFor="let option of field.options" [value]="option">{{ option }}</option>
        </select>
        
        <div *ngIf="form.get(field.name)?.invalid && (form.get(field.name)?.dirty || form.get(field.name)?.touched)" 
             class="field-error">
          <span *ngIf="form.get(field.name)?.errors?.['required']">Campo obrigatório</span>
          <span *ngIf="form.get(field.name)?.errors?.['minlength']">Mínimo de {{ field.minLength }} caracteres</span>
          <span *ngIf="form.get(field.name)?.errors?.['maxlength']">Máximo de {{ field.maxLength }} caracteres</span>
          <span *ngIf="form.get(field.name)?.errors?.['min']">Valor mínimo: {{ field.minValue }}</span>
          <span *ngIf="form.get(field.name)?.errors?.['max']">Valor máximo: {{ field.maxValue }}</span>
          <span *ngIf="form.get(field.name)?.errors?.['pattern']">Formato inválido</span>
        </div>
      </div>      
    </form>

    <div class="form-footer">
      <div class="form-actions">
        <button type="submit" (click)="onSubmit()" [disabled]="form.invalid" || isLoading>
          {{ isEditMode ? 'Atualizar' : 'Salvar' }}
        </button>
        <button type="button" (click)="resetForm()">Cancelar</button>
      </div>
    </div>

    <!-- Filtros -->
    <div *ngIf="filterFields.length > 0" class="filter-container">
      <h2>Filtros</h2>
      <form [formGroup]="filterForm">
        <div *ngFor="let field of filterFields" class="filter-field">
          <label [for]="'filter-' + field.name">{{ field.label }}</label>
          <input [id]="'filter-' + field.name" 
                 [type]="field.dataType === 'number' ? 'number' : 'text'" 
                 [formControlName]="field.name"
                 [disabled]="isLoading">
        </div>
      </form>
    </div>

    <!-- Tabela de Dados -->
    <div class="table-container">
      <div class="table-header">
        <button (click)="onLoadData.emit()" [disabled]="isLoading">
          Atualizar
          <span *ngIf="isLoading" class="button-spinner"></span>
        </button>
      </div>
      
      <div *ngIf="filteredData.length === 0" class="empty-message">
        Nenhum registro encontrado
      </div>
      
      <table *ngIf="filteredData.length > 0">
        <thead>
          <tr>
            <th *ngFor="let field of tableFields">{{ field.label }}</th>
            <th *ngIf="config.actions?.view || config.actions?.edit || config.actions?.delete">Ações</th>
          </tr>
        </thead>
        <tbody>
          <tr *ngFor="let item of filteredData">
            <td *ngFor="let field of tableFields">{{ item[field.name] }}</td>
            <td *ngIf="config.actions?.view || config.actions?.edit || config.actions?.delete" class="actions-cell">
              <button *ngIf="config.actions?.view" (click)="onView.emit(item)" [disabled]="isLoading">👁️</button>
              <button *ngIf="config.actions?.edit" (click)="onEdit(item)" [disabled]="isLoading">✏️</button>
              <button *ngIf="config.actions?.delete" (click)="onDelete(item)" [disabled]="isLoading">🗑️</button>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
  </div>
</div>


==================================================
Arquivo: app/components/dynamic-crud/dynamic-crud.component.scss
==================================================

.crud-container {
  display: flex;
  flex-direction: column;
  height: 100%; /* Ocupa toda a altura da viewport */
  max-width: 100%;
  margin: 0 auto;
  padding: 0 20px;
  font-family: 'Consolas', 'Courier New', monospace;
  background-color: var(--background-dark);
  color: var(--text-light);
}

.loading-overlay {
  position: fixed;
  top: 0;
  left: 0;
  right: 0;
  bottom: 0;
  background: rgba(30, 30, 30, 0.8);
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  z-index: 1000;

  .spinner {
    border: 4px solid rgba(60, 60, 60, 0.5);
    border-top: 4px solid var(--primary-blue);
    border-radius: 50%;
    width: 40px;
    height: 40px;
    animation: spin 1s linear infinite;
    margin-bottom: 15px;
  }

  p {
    color: var(--text-light);
  }
}

.error-message {
  color: var(--error-color);
  padding: 15px;
  margin: 20px 0;
  border: 1px solid #5c2a2a;
  background-color: #2e1e1e;
  border-radius: 4px;
  text-align: center;
}

.content-container {
  display: flex;
  flex-direction: column;
  gap: 20px;
}

.form-container, .filter-container, .table-container {
  background: var(--input-bg);
  padding: 20px;
  border-radius: 4px;
  border: 1px solid var(--border-color);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.3);
}

h2 {
  color: var(--primary-blue);
  padding: 5px;
}

.form-field, .filter-field {
  margin-bottom: 15px;

  label {
    display: block;
    margin-bottom: 5px;
    color: var(--accent-orange);
    font-size: 0.9rem;
  }

  input, select, textarea {
    width: 100%;
    padding: 8px 12px;
    background-color: var(--input-bg);
    border: 1px solid var(--border-color);
    border-radius: 4px;
    color: var(--text-light);
    font-family: 'Consolas', 'Courier New', monospace;
    transition: border-color 0.3s;

    &:focus {
      outline: none;
      border-color: var(--primary-blue);
      box-shadow: 0 0 0 2px rgba(0, 122, 204, 0.3);
    }

    &:disabled {
      opacity: 0.6;
      cursor: not-allowed;
    }
  }

  select {
    appearance: none;
    background-image: url("data:image/svg+xml;charset=UTF-8,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='%23d19a66'%3e%3cpath d='M7 10l5 5 5-5z'/%3e%3c/svg%3e");
    background-repeat: no-repeat;
    background-position: right 8px center;
    background-size: 16px;
  }

  .field-error {
    color: var(--error-color);
    font-size: 0.8rem;
    margin-top: 5px;
  }
}

.form-actions {
  margin-top: 20px;
  display: flex;
  gap: 10px;

  button {
    padding: 8px 16px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-family: 'Consolas', 'Courier New', monospace;
    transition: all 0.2s;
    position: relative;

    &[type="submit"] {
      background-color: var(--primary-blue);
      color: white;

      &:disabled {
        background-color: #3a3d41;
        color: #5a5a5a;
        cursor: not-allowed;
      }
    }

    &[type="button"] {
      background-color: #3a3d41;
      color: var(--text-light);

      &:hover:not(:disabled) {
        background-color: #45494e;
      }
    }

    &:disabled {
      cursor: not-allowed;
      opacity: 0.6;
    }

    .button-spinner {
      display: inline-block;
      width: 16px;
      height: 16px;
      border: 2px solid rgba(255, 255, 255, 0.3);
      border-radius: 50%;
      border-top-color: white;
      animation: spin 1s ease-in-out infinite;
      margin-left: 8px;
    }
  }
}

.table-container {
  .table-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 15px;

    button {
      padding: 6px 12px;
      background-color: var(--primary-blue);
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      display: flex;
      align-items: center;
      gap: 8px;

      &:disabled {
        background-color: #3a3d41;
        cursor: not-allowed;
      }

      .button-spinner {
        display: inline-block;
        width: 14px;
        height: 14px;
        border: 2px solid rgba(255, 255, 255, 0.3);
        border-radius: 50%;
        border-top-color: white;
        animation: spin 1s ease-in-out infinite;
      }
    }
  }    


  .empty-message {
    color: #5a5a5a;
    text-align: center;
    padding: 20px;
    font-style: italic;
  }

  table {
    width: 100%;
    border-collapse: collapse;
    font-size: 0.9rem;

    th, td {
      padding: 12px;
      text-align: left;
      border-bottom: 1px solid var(--border-color);
    }

    th {
      background-color: #252526;
      color: var(--primary-blue);
      font-weight: normal;
    }

    tr:hover {
      background-color: #2a2d2e;
    }
  }
}

.actions-cell {
  display: flex;
  gap: 5px;

  button {
    background: none;
    border: none;
    color: var(--text-light);
    cursor: pointer;
    padding: 5px;
    border-radius: 3px;
    transition: background-color 0.2s;

    &:hover:not(:disabled) {
      background-color: #3a3d41;
    }

    &:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }
  }
}

@keyframes spin {
  0% { transform: rotate(0deg); }
  100% { transform: rotate(360deg); }
}

/* Sistema de grid flexível */
.form-container {
  display: grid;
  grid-template-columns: repeat(auto-fill, minmax(150px, 1fr));
  gap: 15px;
}

/* Classes de tamanho com spans de coluna */
.form-field {
  &.xs-field { grid-column: span 1; }  /* até 15 chars - ocupa 1 coluna */
  &.sm-field { grid-column: span 1; }  /* 16-30 chars - ocupa 1 coluna */
  &.md-field { grid-column: span 1; }  /* 31-50 chars - ocupa 1 coluna */
  &.lg-field { grid-column: span 2; }  /* 51-100 chars - ocupa 2 colunas */
  &.xl-field { grid-column: span 3; }  /* 101-200 chars - ocupa 3 colunas */
  &.full-width { grid-column: 1 / -1; } /* ocupa todas as colunas */

  /* Garante que os inputs ocupem 100% */
  input, select, textarea {
    width: 100%;
    box-sizing: border-box;
  }

  textarea {
    min-height: 100px;
  }
}

/* Ajuste para telas pequenas */
@media (max-width: 768px) {
  .form-container {
    grid-template-columns: 1fr;
  }
  
  .form-field {
    grid-column: span 1 !important;
  }
}


==================================================
Arquivo: app/components/dynamic-crud/dynamic-crud.component.spec.ts
==================================================

/* tslint:disable:no-unused-variable */
import { async, ComponentFixture, TestBed } from '@angular/core/testing';
import { By } from '@angular/platform-browser';
import { DebugElement } from '@angular/core';

import { DynamicCrudComponent } from './dynamic-crud.component';

describe('DynamicCrudComponent', () => {
  let component: DynamicCrudComponent;
  let fixture: ComponentFixture<DynamicCrudComponent>;

  beforeEach(async(() => {
    TestBed.configureTestingModule({
      declarations: [ DynamicCrudComponent ]
    })
    .compileComponents();
  }));

  beforeEach(() => {
    fixture = TestBed.createComponent(DynamicCrudComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/dynamic-crud/dynamic-crud.component.ts
==================================================

import { Component, Input, Output, EventEmitter, OnInit } from '@angular/core';
import { FormBuilder, FormGroup, Validators, ReactiveFormsModule } from '@angular/forms';
import { CommonModule } from '@angular/common';
import { FieldConfig, DynamicTableConfig } from '../../interface/Field-config.model';
import { NgxMaskDirective, NgxMaskPipe, provideNgxMask } from 'ngx-mask';

@Component({
  selector: 'app-dynamic-crud',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './dynamic-crud.component.html',
  styleUrls: ['./dynamic-crud.component.scss'],
  providers: [provideNgxMask()]
})
export class DynamicCrudComponent implements OnInit {
  @Input() config?: DynamicTableConfig;
  @Input() initialData: any[] = [];
  @Input() isLoading: boolean = false;
  @Input() error: string | null = null;
  
  @Output() onCreate = new EventEmitter<any>();
  @Output() onUpdate = new EventEmitter<{id: number, data: any}>();
  @Output() onRemove = new EventEmitter<number>();
  @Output() onLoadData = new EventEmitter<void>();
  @Output() onView = new EventEmitter<any>();
  
  form!: FormGroup;
  data: any[] = [];
  isEditMode = false;
  currentEditId: number | null = null;
  filterForm!: FormGroup;
  filteredData: any[] = [];

  constructor(private fb: FormBuilder) {}

  ngOnInit(): void {
    if (this.config) {
      this.initForms();
      this.data = [...this.initialData];
      this.applyFilters();
    }
  }

  private initForms(): void {
    // Inicializa o formulário principal
    const formGroup: any = {};
    this.config!.fields
      .forEach(field => {
        const validators = [];
        if (field.required) validators.push(Validators.required);
        if (field.minLength) validators.push(Validators.minLength(field.minLength));
        if (field.maxLength) validators.push(Validators.maxLength(field.maxLength));
        if (field.minValue) validators.push(Validators.min(field.minValue));
        if (field.maxValue) validators.push(Validators.max(field.maxValue));
        if (field.pattern) validators.push(Validators.pattern(field.pattern));
        
        formGroup[field.name] = [field.defaultValue || '', validators];
      });
    this.form = this.fb.group(formGroup);

    // Inicializa o formulário de filtro
    const filterGroup: any = {};
    this.config!.fields
      .filter(field => field.filterable)
      .forEach(field => {
        filterGroup[field.name] = [''];
      });
    this.filterForm = this.fb.group(filterGroup);
    this.filterForm.valueChanges.subscribe(() => this.applyFilters());
  }

  applyFilters(): void {
    if (!this.filterForm) return;
    
    const filterValues = this.filterForm.value;
    this.filteredData = this.data.filter(item => {
      return Object.keys(filterValues).every(key => {
        if (!filterValues[key]) return true;
        return String(item[key]).toLowerCase().includes(String(filterValues[key]).toLowerCase());
      });
    });
  }

  onSubmit(): void {
    if (this.form.invalid) return;

    const formData = this.form.value;
    
    if (this.isEditMode && this.currentEditId !== null) {
      this.onUpdate.emit({id: this.currentEditId, data: formData});
    } else {
      this.onCreate.emit(formData);
    }

    this.resetForm();
  }

  onEdit(item: any): void {
    this.isEditMode = true;
    this.currentEditId = item.id;
    this.form.patchValue(item);
  }

  onDelete(item: any): void {
    if (confirm('Tem certeza que deseja excluir este registro?')) {
      this.onRemove.emit(item.id);
    }
  }

  resetForm(): void {
    this.form.reset();
    this.isEditMode = false;
    this.currentEditId = null;
  }

  refreshData(): void {
    this.data = [...this.initialData];
    this.applyFilters();
  }

  get tableFields(): FieldConfig[] {
    // Inclui apenas campos com showInTable: true
    return this.config?.fields.filter(field => field.showInTable) || [];
  }

  get filterFields(): FieldConfig[] {
    return this.config?.fields.filter(field => field.filterable) || [];
  }

  getFieldSizeClass(field: FieldConfig): string {
    // Campos textarea sempre ocupam linha completa
    if (field.type === 'textarea') return 'form-field full-width';
  
    // Campos sem maxLength assumem tamanho médio
    if (!field.maxLength) return 'form-field md-field';
  
    // Lógica de tamanho baseada em maxLength
    const length = field.maxLength;
    
    if (length <= 15) return 'form-field xs-field';
    if (length <= 30) return 'form-field sm-field';
    if (length <= 50) return 'form-field md-field';
    if (length <= 100) return 'form-field lg-field';
    return 'form-field xl-field';
  }

  getMaskedValue(field: FieldConfig, value: any): string {
    // Aplica a máscara se o campo tiver uma máscara definida
    if (field.mask) {
      const maskPipe = new NgxMaskPipe();
      return maskPipe.transform(value, field.mask);
    }
    return value;
  }
}


==================================================
Arquivo: app/components/icon-bar/icon-bar.component.html
==================================================

<div class="icon-bar">
  <img src="/assets/imagens/home1.jpeg" 
       [class.selected]="selectedImage === 0"
       (click)="selectImage(0)"
       (mouseenter)="hoverImage(0)"
       (mouseleave)="unhoverImage(0)"
       title="Página Inicial">
       
  <img src="/assets/imagens/cadastro2.jpeg"
       [class.selected]="selectedImage === 1"
       (click)="selectImage(1)"
       (mouseenter)="hoverImage(1)"
       (mouseleave)="unhoverImage(1)"
       title="Cadastro">
       
  <img src="/assets/imagens/admin1.jpeg"
       [class.selected]="selectedImage === 2"
       (click)="selectImage(2)"
       (mouseenter)="hoverImage(2)"
       (mouseleave)="unhoverImage(2)"
       title="Administração">
       
  <img src="/assets/imagens/configuracao2.jpeg"
       [class.selected]="selectedImage === 3"
       (click)="selectImage(3)"
       (mouseenter)="hoverImage(3)"
       (mouseleave)="unhoverImage(3)"
       title="Configurações">
       
  <footer class="footer-container">
    <!-- ...existing code... -->
  </footer>
</div>


==================================================
Arquivo: app/components/icon-bar/icon-bar.component.scss
==================================================

.icon-bar {
  display: flex;
  flex-direction: column;
  background-color: var(--header-color);
  width: 62px;
  height: 100%;
  padding: 0.5rem;
  border-right: 1px solid var(--text-color);
  
  img {
    margin-top: 1rem;
    margin-bottom: 1rem;
    width: 40px;
    height: 40px;
    cursor: pointer;
    border: 3px groove var(--header-color);
    box-shadow: 2px 2px 5px var(--text-color);
    z-index: 1;
    transition: all 0.3s ease;
    
    &:hover {
      border-color: green;
      box-shadow: 0 0 10px green;
    }
    
    &.selected {
      border-color: blue;
      box-shadow: 0 0 10px blue;
    }
  }
  
}


==================================================
Arquivo: app/components/icon-bar/icon-bar.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { IconBarComponent } from './icon-bar.component';

describe('IconBarComponent', () => {
  let component: IconBarComponent;
  let fixture: ComponentFixture<IconBarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [IconBarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(IconBarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/icon-bar/icon-bar.component.ts
==================================================

import { Component, EventEmitter, Output } from '@angular/core';
import { MatIconModule } from '@angular/material/icon';
import { Router } from '@angular/router';

interface SidebarOption {
  icon: string;
  text: string;
  route: string;
}

@Component({
  selector: 'app-icon-bar',
  templateUrl: './icon-bar.component.html',
  styleUrls: ['./icon-bar.component.scss'],
  standalone: true,
  imports: [MatIconModule]
})
export class IconBarComponent {
  constructor(private router: Router) {}

  selectedImage: number | null = null;
  
  // Emite as opções para o sidebar quando um ícone é clicado
  @Output() sendOptionsToSidebar = new EventEmitter<SidebarOption[]>();

  // Lista de opções para cada ícone
  private optionsForIcons: SidebarOption[][] = [
    // Opções para o ícone 0 (Home)
    [
      { icon: 'home', text: 'Página Inicial', route: '/home' },
      { icon: 'dashboard', text: 'Dashboard', route: '/dashboard' }
    ],
    // Opções para o ícone 1 (Cadastro)
    [
      { icon: 'account_balance', text: 'Banco', route: '/cadastro/banco' },
      { icon: 'credit_card', text: 'Cartão', route: '/cadastro/cartao' },
      { icon: 'people', text: 'Clientes', route: '/cadastro/clientes' },
      { icon: 'account_balance_wallet', text: 'Conta', route: '/cadastro/conta' },
      { icon: 'business', text: 'Empresa Cliente', route: '/empresa-cliente' },
      { icon: 'local_shipping', text: 'Fornecedor', route: '/cadastro/fornecedor' },
      { icon: 'badge', text: 'Funcionários', route: '/cadastro/funcionarios' },
      { icon: 'store', text: 'Loja', route: '/cadastro/loja' },
      { icon: 'apps', text: 'Módulo', route: '/cadastro/modulo' },
      { icon: 'assignment', text: 'Plano Contratado', route: '/cadastro/plano-contratado' },
      { icon: 'inventory', text: 'Produto', route: '/cadastro/produto' },
      { icon: 'person', text: 'Usuário', route: '/cadastro/usuario' }
    ],
    // Opções para o ícone 2 (Admin)
    [
      { icon: 'admin_panel_settings', text: 'Permissões', route: '/admin/permissoes' },
      { icon: 'people', text: 'Usuários', route: '/admin/usuarios' }
    ],
    // Opções para o ícone 3 (Config)
    [
      { icon: 'settings', text: 'Configurações', route: '/configuracoes' },
      { icon: 'palette', text: 'Temas', route: '/temas' }
    ]
  ];

  selectImage(index: number): void {
    if (this.selectedImage === index) {
      // Se clicar no mesmo ícone, deseleciona
      this.selectedImage = null;
      this.sendOptionsToSidebar.emit([]);
    } else {
      // Seleciona o novo ícone e envia as opções correspondentes
      this.selectedImage = index;
      this.sendOptionsToSidebar.emit(this.optionsForIcons[index]);
    }
  }

  hoverImage(index: number): void {
    // Lógica adicional se necessário
  }
  
  unhoverImage(index: number): void {
    // Lógica adicional se necessário
  }
}


==================================================
Arquivo: app/components/sidebar/sidebar.component.html
==================================================

<mat-sidenav-container>
  <mat-sidenav mode="side" opened>
    <mat-nav-list>
      <ng-container *ngFor="let option of options">
        <a mat-list-item (click)="navigateTo(option.route)">
          <mat-icon>{{option.icon}}</mat-icon>
          {{option.text}}
        </a>
      </ng-container>
    </mat-nav-list>
  </mat-sidenav>
</mat-sidenav-container>


==================================================
Arquivo: app/components/sidebar/sidebar.component.scss
==================================================

::ng-deep .mdc-list-item__primary-text {
  color: var(--text-color) !important;
}

mat-sidenav-container {
  height: 100vh;
  background-color: var(--background-color);
  color: var(--text-color) !important;

  mat-sidenav {
    width: 250px;  /* Aumentado para melhor visualização */
    height: 100%;
    background-color: var(--sidebar-color);
    padding-top: 16px;

    mat-nav-list {
      padding-top: 0;

      a {
        color: var(--text-color);
        display: flex;
        align-items: center;
        padding: 8px 16px;

        &:hover {
          background-color: rgba(255, 255, 255, 0.1);
        }

        mat-icon {
          margin-right: 12px;
          color: var(--icon-color);
        }
      }
    }
  }

  mat-sidenav-content {
    background-color: var(--background-color);
    color: var(--text-color);
    padding: 16px;
  }
}


==================================================
Arquivo: app/components/sidebar/sidebar.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { SidebarComponent } from './sidebar.component';

describe('SidebarComponent', () => {
  let component: SidebarComponent;
  let fixture: ComponentFixture<SidebarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [SidebarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(SidebarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/sidebar/sidebar.component.ts
==================================================

import { CommonModule } from '@angular/common';
import { Component, Input } from '@angular/core';
import { MatIconModule } from '@angular/material/icon';
import { MatListModule } from '@angular/material/list';
import { MatSidenavModule } from '@angular/material/sidenav';
import { Router } from '@angular/router';

interface SidebarOption {
  icon: string;
  text: string;
  route: string;
}

@Component({
  selector: 'app-sidebar',
  templateUrl: './sidebar.component.html',
  styleUrls: ['./sidebar.component.scss'],
  standalone: true,
  imports: [MatIconModule, MatListModule, CommonModule, MatSidenavModule]
})
export class SidebarComponent {
  constructor(private router: Router) {}

  @Input() options: SidebarOption[] = [];

  navigateTo(route: string): void {
    this.router.navigate([route]);
  }
}


==================================================
Arquivo: app/components/plano-form-dialog/plano-form-dialog.component.html
==================================================

<h2 mat-dialog-title>{{ data.mode === 'create' ? 'Novo Plano' : 'Editar Plano' }}</h2>

<mat-dialog-content>
  <form [formGroup]="form" class="form-container">
    <mat-form-field appearance="outline">
      <mat-label>Nome</mat-label>
      <input matInput formControlName="nome" required>
      <mat-error *ngIf="form.get('nome')?.hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>

    <mat-form-field appearance="outline">
      <mat-label>Preço Base por Loja</mat-label>
      <input matInput type="number" formControlName="precoBasePorLoja" required>
      <span matTextPrefix>R$&nbsp;</span>
      <mat-error *ngIf="form.get('precoBasePorLoja')?.hasError('required')">
        Campo obrigatório
      </mat-error>
    </mat-form-field>

    <mat-checkbox formControlName="gratuito">Plano Gratuito</mat-checkbox>

    <mat-form-field appearance="outline" *ngIf="!form.get('gratuito')?.value">
      <mat-label>Duração (meses)</mat-label>
      <input matInput type="number" formControlName="tempoDuracaoEmMeses">
    </mat-form-field>

    <mat-form-field appearance="outline">
      <mat-label>Módulos</mat-label>
      <mat-select formControlName="modulos" multiple>
        <mat-option *ngFor="let modulo of modulosDisponiveis" [value]="modulo.id">
          {{ modulo.nome }}
        </mat-option>
      </mat-select>
    </mat-form-field>
  </form>
</mat-dialog-content>

<mat-dialog-actions align="end">
  <button mat-button mat-dialog-close>Cancelar</button>
  <button
    mat-flat-button
    color="primary"
    (click)="save()"
    [disabled]="form.invalid || saving"
  >
      Salvar
  </button>
</mat-dialog-actions>



==================================================
Arquivo: app/components/plano-form-dialog/plano-form-dialog.component.scss
==================================================




==================================================
Arquivo: app/components/plano-form-dialog/plano-form-dialog.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PlanoFormDialogComponent } from './plano-form-dialog.component';

describe('PlanoFormDialogComponent', () => {
  let component: PlanoFormDialogComponent;
  let fixture: ComponentFixture<PlanoFormDialogComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PlanoFormDialogComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(PlanoFormDialogComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/plano-form-dialog/plano-form-dialog.component.ts
==================================================

import { Component, Inject, inject, NgModule } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MAT_DIALOG_DATA, MatDialogModule, MatDialogRef } from '@angular/material/dialog';
import { MatButtonModule } from '@angular/material/button';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { PlanoService } from '../../service/cadastro/plano/Plano.service';
import { MatCheckboxModule } from '@angular/material/checkbox';
import { MatSelectModule } from '@angular/material/select';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';
import { AppComponent } from '../../app.component';

@Component({
  selector: 'app-plano-form-dialog',
  standalone: true,
  imports: [
    CommonModule,
    MatDialogModule,
    MatButtonModule,
    MatInputModule,
    MatFormFieldModule,
    ReactiveFormsModule,
    MatCheckboxModule,
    MatSelectModule
  ],
  templateUrl: './plano-form-dialog.component.html',
  styleUrls: ['./plano-form-dialog.component.scss']
})
export class PlanoFormDialogComponent {
  private readonly fb = inject(FormBuilder);
  private readonly planoService = inject(PlanoService);
  private readonly dialogRef = inject(MatDialogRef<PlanoFormDialogComponent>);

  form = this.fb.group({
    nome: ['', Validators.required],
    precoBasePorLoja: [0, [Validators.required, Validators.min(0)]],
    gratuito: [false],
    tempoDuracaoEmMeses: [null as number | null],
    modulos: [[] as number[]]
  });

  modulosDisponiveis: any[] = [];
  saving = false;

  constructor(@Inject(MAT_DIALOG_DATA) public data: { plano?: any, mode: 'create' | 'edit' }) {
    if (data.plano) {
      this.form.patchValue(data.plano);
    }

    this.carregarModulos();
  }

  async carregarModulos() {
    // Implemente a chamada para carregar os módulos disponíveis
    this.modulosDisponiveis = await this.planoService.getModulosDisponiveis();
  }

  async save() {
    if (this.form.invalid) return;

    this.saving = true;
    try {
      const formValue = this.form.value;

      this.dialogRef.close(true); // Fecha o dialog e indica sucesso
    } catch (error) {
      console.error('Erro ao salvar plano:', error);
    } finally {
      this.saving = false;
    }
  }
}

@NgModule({
  declarations: [
    // other components
  ],
  imports: [
    MatDialogModule,
    MatProgressSpinnerModule,
    // other modules
  ],
  providers: [],
  // bootstrap: [AppComponent]
})
export class AppModule { }



==================================================
Arquivo: app/components/toolbar/toolbar.component.html
==================================================

<mat-toolbar color="primary">
  <div class="toolbar">
    <button mat-icon-button (click)="toggleSidebar()">
      <mat-icon>menu</mat-icon>
    </button>
    <span>Gestão 360</span>
    <span class="spacer"></span>
    <button mat-icon-button (click)="login()">
      <mat-icon>account_circle</mat-icon>
    </button>
  </div>

  <button mat-icon-button>
    <mat-icon>search</mat-icon>
  </button>

  <button mat-icon-button>
    <mat-icon>notifications</mat-icon>
  </button>

  <button mat-icon-button [matMenuTriggerFor]="menu">
    <mat-icon>account_circle</mat-icon>
  </button>

  <mat-menu #menu="matMenu">
    <button mat-menu-item>
      <mat-icon>settings</mat-icon>
      <span>Configurações</span>
    </button>
    <button mat-menu-item>
      <mat-icon>logout</mat-icon>
      <span>Sair</span>
    </button>
  </mat-menu>
</mat-toolbar>



==================================================
Arquivo: app/components/toolbar/toolbar.component.scss
==================================================

mat-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--primary-color);
  color: var(--text-color);
  width: 100vw;
  top: 0;

  .toolbar {
    display: flex;
    align-items: center;
    justify-content: space-between;
    background-color: var(--header-color);
    color: var(--text-color);
    width: 100%;
  }

  .spacer {
    flex: 1;
  }

  .spacer {
    flex: 1;
  }

  button {
    margin: 0 8px;
  }
}



==================================================
Arquivo: app/components/toolbar/toolbar.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ToolbarComponent } from './toolbar.component';

describe('ToolbarComponent', () => {
  let component: ToolbarComponent;
  let fixture: ComponentFixture<ToolbarComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ToolbarComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ToolbarComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/toolbar/toolbar.component.ts
==================================================

import { Component, EventEmitter, Output } from '@angular/core';
import { MatIconModule } from '@angular/material/icon';
import { MatButtonModule } from '@angular/material/button';
import { MatToolbarModule } from '@angular/material/toolbar';
import { MatMenuModule } from '@angular/material/menu';
import { Router } from '@angular/router';

@Component({
  selector: 'app-toolbar',
  templateUrl: './toolbar.component.html',
  styleUrls: ['./toolbar.component.scss'],
  standalone: true,
  imports: [
    MatIconModule,
    MatButtonModule,
    MatToolbarModule,
    MatMenuModule
  ]
})
export class ToolbarComponent {

  constructor(private router: Router) {}

  toggleSidebar() {
    // Lógica para alternar a visibilidade da sidebar
  }

  login() {
    this.router.navigate(['login']); // Navega para a rota raiz 
  }

}



==================================================
Arquivo: app/components/modulo-form-dialog/modulo-form-dialog.component.html
==================================================

<h2 mat-dialog-title>{{ title }}</h2>

<mat-dialog-content>
  <form [formGroup]="form" class="form-container">
    <mat-form-field appearance="outline">
      <mat-label>Nome do Módulo</mat-label>
      <input
        matInput
        formControlName="nome"
        placeholder="Ex: Gestão Financeira"
        required
      >
      <mat-error *ngIf="form.get('nome')?.hasError('required')">
        Nome é obrigatório
      </mat-error>
      <mat-error *ngIf="form.get('nome')?.hasError('maxlength')">
        Máximo de 100 caracteres
      </mat-error>
    </mat-form-field>

    <mat-form-field appearance="outline">
      <mat-label>Percentual de Custo (%)</mat-label>
      <input
        matInput
        type="number"
        formControlName="percentualCusto"
        min="0"
        max="100"
        required
      >
      <span matTextSuffix>%</span>
      <mat-error *ngIf="form.get('percentualCusto')?.hasError('required')">
        Percentual é obrigatório
      </mat-error>
      <mat-error *ngIf="form.get('percentualCusto')?.hasError('min')">
        Deve ser maior ou igual a 0
      </mat-error>
      <mat-error *ngIf="form.get('percentualCusto')?.hasError('max')">
        Deve ser menor ou igual a 100
      </mat-error>
    </mat-form-field>
  </form>
</mat-dialog-content>

<mat-dialog-actions align="end">
  <button
    mat-button
    color="warn"
    (click)="onCancel()"
    [disabled]="loading"
  >
    Cancelar
  </button>

  <button
    mat-flat-button
    color="primary"
    (click)="onSubmit()"
    [disabled]="form.invalid || loading"
  >
    @if (loading) {
      <mat-icon>
        <mat-spinner diameter="20" color="accent"></mat-spinner>
      </mat-icon>
    }
    @if (!loading) {
      {{ isEditMode ? 'Atualizar' : 'Salvar' }}
    }
  </button>
</mat-dialog-actions>



==================================================
Arquivo: app/components/modulo-form-dialog/modulo-form-dialog.component.scss
==================================================

.form-container {
  display: flex;
  flex-direction: column;
  gap: 1.5rem;
  padding: 1rem 0;
  min-width: 400px;
}

mat-form-field {
  width: 100%;
}

mat-spinner {
  display: inline-block;
  margin-right: 8px;
}

.mat-mdc-dialog-actions {
  padding: 1rem 0 0;
  margin-top: 1rem;
  border-top: 1px solid rgba(0, 0, 0, 0.12);
}



==================================================
Arquivo: app/components/modulo-form-dialog/modulo-form-dialog.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ModuloFormDialogComponent } from './modulo-form-dialog.component';

describe('ModuloFormDialogComponent', () => {
  let component: ModuloFormDialogComponent;
  let fixture: ComponentFixture<ModuloFormDialogComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ModuloFormDialogComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ModuloFormDialogComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/modulo-form-dialog/modulo-form-dialog.component.ts
==================================================

import { Component, Inject, inject } from '@angular/core';
import { CommonModule } from '@angular/common';
import {
  MAT_DIALOG_DATA,
  MatDialogRef,
  MatDialogModule
} from '@angular/material/dialog';
import {
  FormBuilder,
  FormGroup,
  Validators,
  ReactiveFormsModule
} from '@angular/forms';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { ModuloService } from '../../service/cadastro/modulo/Modulo.service';
import { MatProgressSpinnerModule } from '@angular/material/progress-spinner';

@Component({
  selector: 'app-modulo-form-dialog',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatDialogModule,
    MatFormFieldModule,
    MatInputModule,
    MatButtonModule,
    MatIconModule,
    MatProgressSpinnerModule
  ],
  templateUrl: './modulo-form-dialog.component.html',
  styleUrls: ['./modulo-form-dialog.component.scss']
})
export class ModuloFormDialogComponent {
  private readonly fb = inject(FormBuilder);
  private readonly dialogRef = inject(MatDialogRef<ModuloFormDialogComponent>);
  private readonly moduloService = inject(ModuloService);

  form: FormGroup;
  loading = false;
  mode: 'create' | 'edit' = 'create'; // Valor padrão
  isEditMode: boolean = false;

  constructor(@Inject(MAT_DIALOG_DATA) public data: {
    modulo?: any,
    mode?: 'create' | 'edit' // Tornando opcional
  }) {
    // Define o mode com fallback para 'create' se não fornecido
    this.mode = data?.mode || 'create';

    this.form = this.fb.group({
      nome: ['', [Validators.required, Validators.maxLength(100)]],
      percentualCusto: [
        0,
        [Validators.required, Validators.min(0), Validators.max(100)]
      ]
    });

    if (this.mode === 'edit' && data?.modulo) {
      this.form.patchValue(data.modulo);
    }
  }

  get title(): string {
    return this.mode === 'create' ? 'Novo Módulo' : 'Editar Módulo';
  }

  async onSubmit(): Promise<void> {
    if (this.form.invalid || this.loading) return;

    this.loading = true;
    try {
      const formData = this.form.value;

      if (this.mode === 'edit') {
        await this.moduloService.update(this.data.modulo.id, formData).toPromise();
      } else {
        await this.moduloService.create(formData).toPromise();
      }

      this.dialogRef.close(true);
    } catch (error) {
      console.error('Erro ao salvar módulo:', error);
    } finally {
      this.loading = false;
    }
  }

  onCancel(): void {
    this.dialogRef.close(false);
  }
}



==================================================
Arquivo: app/components/footer/footer.component.html
==================================================

<mat-toolbar color="primary">
  <span class="spacer"></span>
  <span>Status: Conectado</span>
  <span class="spacer"></span>
  <button mat-icon-button>
    <mat-icon>notifications</mat-icon>
  </button>
  <footer class="footer-container">
    <p>© 2025 Gestão 360</p>
  </footer>
</mat-toolbar>



==================================================
Arquivo: app/components/footer/footer.component.scss
==================================================

mat-toolbar {
  display: flex;
  align-items: center;
  justify-content: space-between;
  background-color: var(--header-color);
  color: white;

  .spacer {
    flex: 1;
  }

  button {
    margin: 0 8px;
  }
}

footer {
  background-color: var(--footer-color);
  color: var(--text-color);
  text-align: center;
  margin-top: auto;
}

::ng-deep .mat-toolbar-row {
  height: 36px;
  align-items: center !important;
}



==================================================
Arquivo: app/components/footer/footer.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { FooterComponent } from './footer.component';

describe('FooterComponent', () => {
  let component: FooterComponent;
  let fixture: ComponentFixture<FooterComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [FooterComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(FooterComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/components/footer/footer.component.ts
==================================================

import { Component } from '@angular/core';
import { MatIconModule } from '@angular/material/icon';
import { MatToolbarModule } from '@angular/material/toolbar';

@Component({
  selector: 'app-footer',
  templateUrl: './footer.component.html',
  styleUrls: ['./footer.component.scss'],
  standalone: true,
  imports: [MatIconModule, MatToolbarModule]
})
export class FooterComponent {}



==================================================
Arquivo: app/pages/cadastros/empresa-cliente/empresa-cliente.component.html
==================================================

<p>empresa-cliente works!</p>



==================================================
Arquivo: app/pages/cadastros/empresa-cliente/empresa-cliente.component.scss
==================================================




==================================================
Arquivo: app/pages/cadastros/empresa-cliente/empresa-cliente.component.ts
==================================================

import { Component, OnInit } from '@angular/core';
import { DynamicCrudComponent } from '../../../components/dynamic-crud/dynamic-crud.component';
import { EmpresaServiceService } from '../../../service/cadastro/empresa/EmpresaService.service';
import { CommonModule } from '@angular/common';
import { MessageService } from '../../../service/Message.service';
import { FieldConfig } from '../../../interface/Field-config.model';

interface Empresa {
  id: number;
  nome: string;
  cnpj: string;
  endereco?: string;
  telefone?: string;
  email?: string;
  planoId: number;
}

@Component({
  selector: 'app-empresa-cliente',
  standalone: true,
  imports: [CommonModule, DynamicCrudComponent],
  template: `
    @if (loading) {
      <div class="loading-spinner">Carregando configuração...</div>
    } @else if (error) {
      <div class="error-message">{{ error }}</div>
    } @else {
      <app-dynamic-crud 
        [config]="config"
        [initialData]="empresas"
        (onCreate)="createEmpresa($event)"
        (onUpdate)="updateEmpresa($event)"
        (onRemove)="deleteEmpresa($event)"
        (onLoadData)="loadEmpresas()"
      ></app-dynamic-crud>
    }
  `,
  styles: [`
    .loading-spinner {
      padding: 2rem;
      text-align: center;
      color: #666;
    }
    
    .error-message {
      color: #d32f2f;
      padding: 1rem;
      background-color: #fde0e0;
      border-radius: 4px;
      margin: 1rem 0;
    }
  `]
})
export class EmpresaClienteComponent implements OnInit {
  config: any = null;
  empresas: Empresa[] = [];
  loading = true;
  error: string | null = null;

  constructor(
    private empresaService: EmpresaServiceService,
    private messageService: MessageService
  ) {}

  ngOnInit(): void {
    this.loadConfig();
    this.loadEmpresas();
  }

  loadConfig(): void {
    this.empresaService.getConfig().subscribe({
      next: (fields: FieldConfig[]) => {
        this.config = {
          title: 'Cadastro de Empresas',
          fields: fields,
          actions: {
            view: true,
            edit: true,
            delete: true
          }
        };
        this.loading = false;
      },
      error: (err) => {
        this.error = 'Falha ao carregar configuração.';
        this.loading = false;
        this.messageService.error('Erro ao carregar configuração do formulário');
      }
    });
  }

  loadEmpresas(): void {
    this.empresaService.getAll().subscribe({
      next: (data: Empresa[]) => {
        this.empresas = data;
      },
      error: (err) => {
        this.messageService.error('Erro ao carregar lista de empresas');
      }
    });
  }

  createEmpresa(data: Omit<Empresa, 'id'>): void {
    this.empresaService.create(data).subscribe({
      next: () => {
        this.messageService.success('Empresa criada com sucesso!');
        this.loadEmpresas();
      },
      error: (err) => {
        this.messageService.error('Erro ao criar empresa');
      }
    });
  }

  updateEmpresa({id, data}: {id: number, data: Partial<Empresa>}): void {
    this.empresaService.update(id, data).subscribe({
      next: () => {
        this.messageService.success('Empresa atualizada com sucesso!');
        this.loadEmpresas();
      },
      error: (err) => {
        this.messageService.error('Erro ao atualizar empresa');
      }
    });
  }

  deleteEmpresa(id: number): void {
    this.empresaService.delete(id).subscribe({
      next: () => {
        this.messageService.success('Empresa excluída com sucesso!');
        this.loadEmpresas();
      },
      error: (err) => {
        this.messageService.error('Erro ao excluir empresa');
      }
    });
  }
}


==================================================
Arquivo: app/pages/cadastros/cartao/cartao.component.html
==================================================

<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-credit-card me-2"></i>
          {{ isEditing() ? 'Editar Cartão' : 'Cadastrar Novo Cartão' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="cartaoForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-4">
              <label class="form-label">Número</label>
              <input type="text" class="form-control" formControlName="numero" [class.is-invalid]="cartaoForm.get('numero')?.invalid && cartaoForm.get('numero')?.touched">
              <div class="invalid-feedback">Número deve ter 16 dígitos</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Bandeira</label>
              <input type="text" class="form-control" formControlName="bandeira" [class.is-invalid]="cartaoForm.get('bandeira')?.invalid && cartaoForm.get('bandeira')?.touched">
              <div class="invalid-feedback">Bandeira é obrigatória</div>
            </div>
            <div class="col-md-2">
              <label class="form-label">Tipo</label>
              <select class="form-control" formControlName="tipo" [class.is-invalid]="cartaoForm.get('tipo')?.invalid && cartaoForm.get('tipo')?.touched">
                <option value="CREDITO">Crédito</option>
                <option value="DEBITO">Débito</option>
              </select>
              <div class="invalid-feedback">Tipo é obrigatório</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Validade</label>
              <input type="date" class="form-control" formControlName="dataValidade" [class.is-invalid]="cartaoForm.get('dataValidade')?.invalid && cartaoForm.get('dataValidade')?.touched">
              <div class="invalid-feedback">Data de validade é obrigatória</div>
            </div>
            <div class="col-md-6">
              <label class="form-label">Titular</label>
              <input type="text" class="form-control" formControlName="titular" [class.is-invalid]="cartaoForm.get('titular')?.invalid && cartaoForm.get('titular')?.touched">
              <div class="invalid-feedback">Titular é obrigatório</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : cartaoForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="cartaoForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Número</th>
                <th>Bandeira</th>
                <th>Tipo</th>
                <th>Validade</th>
                <th>Titular</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let cartao of cartoes()">
                <td>{{ cartao.numero }}</td>
                <td>{{ cartao.bandeira }}</td>
                <td>{{ cartao.tipo }}</td>
                <td>{{ cartao.dataValidade | date:'dd/MM/yyyy' }}</td>
                <td>{{ cartao.titular }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(cartao)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteCartao(cartao.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/cartao/cartao.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/cartao/cartao.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { CartaoService } from '../../../service/cadastro/Cartao/Cartao.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Cartao, CreateCartaoDTO, UpdateCartaoDTO } from '../../../interface/cadastro/Cartao';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-cartao',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './cartao.component.html',
  styleUrls: ['./cartao.component.scss']
})
export class CartaoComponent implements OnInit {
  private cartaoService = inject(CartaoService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  cartoes = signal<Cartao[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  cartaoForm = this.fb.group({
    numero: ['', [Validators.required, Validators.pattern(/^\d{16}$/)]],
    bandeira: ['', Validators.required],
    tipo: ['', Validators.required],
    dataValidade: ['', Validators.required],
    titular: ['', Validators.required]
  });

  ngOnInit(): void {
    this.loadCartoes();
  }

  async loadCartoes() {
    this.loading.set(true);
    try {
      this.cartaoService.getAll().subscribe(cartoes => {
        this.cartoes.set(cartoes);
      });
    } catch (error) {
      this.showError('Erro ao carregar cartões');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(cartao: Cartao) {
    this.currentEditId.set(cartao.id);
    this.isEditing.set(true);
    this.cartaoForm.patchValue({
      numero: cartao.numero,
      bandeira: cartao.bandeira,
      tipo: cartao.tipo,
      dataValidade: new Date(cartao.dataValidade).toISOString().split('T')[0],
      titular: cartao.titular
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.cartaoForm.reset();
  }

  async onSubmit() {
    if (this.cartaoForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.cartaoForm.value;
      const cartaoData = {
        ...formData,
        dataValidade: new Date(formData.dataValidade!)
      };

      if (this.isEditing() && this.currentEditId()) {
        await this.cartaoService.update(this.currentEditId()!, cartaoData as UpdateCartaoDTO);
        this.showSuccess('Cartão atualizado com sucesso');
      } else {
        await this.cartaoService.create(cartaoData as CreateCartaoDTO);
        this.showSuccess('Cartão criado com sucesso');
      }

      this.cancelEdit();
      this.loadCartoes();
    } catch (error) {
      this.showError('Erro ao salvar cartão');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteCartao(id: string) {
    if (confirm('Tem certeza que deseja excluir este cartão?')) {
      try {
        await this.cartaoService.delete(id);
        this.showSuccess('Cartão excluído com sucesso');
        this.loadCartoes();
      } catch (error) {
        this.showError('Erro ao excluir cartão');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/cadastros/fornecedor/fornecedor.component.html
==================================================

<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-truck me-2"></i>
          {{ isEditing() ? 'Editar Fornecedor' : 'Cadastrar Novo Fornecedor' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="fornecedorForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <label class="form-label">Razão Social</label>
              <input type="text" class="form-control" formControlName="razaoSocial" [class.is-invalid]="fornecedorForm.get('razaoSocial')?.invalid && fornecedorForm.get('razaoSocial')?.touched">
              <div class="invalid-feedback">Razão Social é obrigatória (máx. 100 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">CNPJ</label>
              <input type="text" class="form-control" formControlName="cnpj" [class.is-invalid]="fornecedorForm.get('cnpj')?.invalid && fornecedorForm.get('cnpj')?.touched">
              <div class="invalid-feedback">CNPJ deve ter 14 dígitos</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Email</label>
              <input type="email" class="form-control" formControlName="email" [class.is-invalid]="fornecedorForm.get('email')?.invalid && fornecedorForm.get('email')?.touched">
              <div class="invalid-feedback">Email inválido</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Telefone</label>
              <input type="text" class="form-control" formControlName="telefone" [class.is-invalid]="fornecedorForm.get('telefone')?.invalid && fornecedorForm.get('telefone')?.touched">
              <div class="invalid-feedback">Telefone deve ter 10 ou 11 dígitos</div>
            </div>
            <div class="col-md-6">
              <label class="form-label">Endereço</label>
              <input type="text" class="form-control" formControlName="endereco" [class.is-invalid]="fornecedorForm.get('endereco')?.invalid && fornecedorForm.get('endereco')?.touched">
              <div class="invalid-feedback">Endereço é obrigatório (máx. 200 caracteres)</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : fornecedorForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="fornecedorForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Razão Social</th>
                <th>CNPJ</th>
                <th>Email</th>
                <th>Telefone</th>
                <th>Endereço</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let fornecedor of fornecedores()">
                <td>{{ fornecedor.razaoSocial }}</td>
                <td>{{ fornecedor.cnpj }}</td>
                <td>{{ fornecedor.email }}</td>
                <td>{{ fornecedor.telefone }}</td>
                <td>{{ fornecedor.endereco }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(fornecedor)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteFornecedor(fornecedor.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/fornecedor/fornecedor.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/fornecedor/fornecedor.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { FornecedorService } from '../../../service/cadastro/Fornecedor/Fornecedor.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Fornecedor, CreateFornecedorDTO, UpdateFornecedorDTO } from '../../../interface/cadastro/Fornecedor';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-fornecedor',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './fornecedor.component.html',
  styleUrls: ['./fornecedor.component.scss']
})
export class FornecedorComponent implements OnInit {
  private fornecedorService = inject(FornecedorService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  fornecedores = signal<Fornecedor[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  fornecedorForm = this.fb.group({
    razaoSocial: ['', [Validators.required, Validators.maxLength(100)]],
    cnpj: ['', [Validators.required, Validators.pattern(/^\d{14}$/)]],
    email: ['', [Validators.required, Validators.email]],
    telefone: ['', [Validators.required, Validators.pattern(/^\d{10,11}$/)]],
    endereco: ['', [Validators.required, Validators.maxLength(200)]]
  });

  ngOnInit(): void {
    this.loadFornecedores();
  }

  async loadFornecedores() {
    this.loading.set(true);
    try {
      this.fornecedorService.getAll().subscribe(fornecedores => {
        this.fornecedores.set(fornecedores);
      });
    } catch (error) {
      this.showError('Erro ao carregar fornecedores');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(fornecedor: Fornecedor) {
    this.currentEditId.set(fornecedor.id);
    this.isEditing.set(true);
    this.fornecedorForm.patchValue({
      razaoSocial: fornecedor.razaoSocial,
      cnpj: fornecedor.cnpj,
      email: fornecedor.email,
      telefone: fornecedor.telefone,
      endereco: fornecedor.endereco
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.fornecedorForm.reset();
  }

  async onSubmit() {
    if (this.fornecedorForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.fornecedorForm.value;

      if (this.isEditing() && this.currentEditId()) {
        await this.fornecedorService.update(this.currentEditId()!, formData as UpdateFornecedorDTO);
        this.showSuccess('Fornecedor atualizado com sucesso');
      } else {
        await this.fornecedorService.create(formData as CreateFornecedorDTO);
        this.showSuccess('Fornecedor criado com sucesso');
      }

      this.cancelEdit();
      this.loadFornecedores();
    } catch (error) {
      this.showError('Erro ao salvar fornecedor');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteFornecedor(id: string) {
    if (confirm('Tem certeza que deseja excluir este fornecedor?')) {
      try {
        await this.fornecedorService.delete(id);
        this.showSuccess('Fornecedor excluído com sucesso');
        this.loadFornecedores();
      } catch (error) {
        this.showError('Erro ao excluir fornecedor');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/cadastros/banco/banco.component.html
==================================================

<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-bank me-2"></i>
          {{ isEditing() ? 'Editar Banco' : 'Cadastrar Novo Banco' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="bancoForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <!-- Código -->
            <div class="col-md-3">
              <label class="form-label">Código</label>
              <input type="text" 
                     class="form-control"
                     formControlName="codigo"
                     [class.is-invalid]="bancoForm.get('codigo')?.invalid && bancoForm.get('codigo')?.touched">
              <div class="invalid-feedback">
                Código é obrigatório (máx. 10 caracteres)
              </div>
            </div>
  
            <!-- Nome -->
            <div class="col-md-6">
              <label class="form-label">Nome do Banco</label>
              <input type="text"
                     class="form-control"
                     formControlName="nome"
                     [class.is-invalid]="bancoForm.get('nome')?.invalid && bancoForm.get('nome')?.touched">
              <div class="invalid-feedback">
                Nome é obrigatório (máx. 100 caracteres)
              </div>
            </div>
  
            <!-- ISPB -->
            <div class="col-md-3">
              <label class="form-label">Código ISPB</label>
              <input type="text"
                     class="form-control"
                     formControlName="ispb"
                     [class.is-invalid]="bancoForm.get('ispb')?.invalid && bancoForm.get('ispb')?.touched">
              <div class="invalid-feedback">
                ISPB é obrigatório (8 dígitos)
              </div>
            </div>
          </div>
  
          <div class="d-flex justify-content-end gap-2">
            <button type="button" 
                    class="btn btn-outline-secondary"
                    (click)="isEditing() ? cancelEdit() : bancoForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            
            <button type="submit" 
                    class="btn btn-primary"
                    [disabled]="bancoForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Código</th>
                <th>Nome</th>
                <th>ISPB</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let banco of bancos()">
                <td>{{ banco.codigo }}</td>
                <td>{{ banco.nome }}</td>
                <td>{{ banco.ispb }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary"
                            (click)="startEdit(banco)"
                            [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger"
                            (click)="deleteBanco(banco.id)"
                            [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/banco/banco.component.scss
==================================================

/* Variáveis do tema VS Code */
:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
  
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
  
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
  
      th {
        background-color: var(--header-color);
      }
    }
  
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
  
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
  
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
  
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
  
    .invalid-feedback {
      color: var(--error-color);
    }
  
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  
  /* Spinner de loading */
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/banco/banco.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { BancoService } from '../../../service/cadastro/Banco.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Banco, CreateBancoDTO, UpdateBancoDTO } from '../../../interface/cadastro/Banco';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-banco',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule
  ],
  templateUrl: './banco.component.html',
  styleUrls: ['./banco.component.scss']
})
export class BancoComponent implements OnInit {
  private bancoService = inject(BancoService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  bancos = signal<Banco[]>([]);
  loading = signal(false);
  searchTerm = signal('');
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  bancoForm = this.fb.group({
    codigo: ['', [Validators.required, Validators.maxLength(10)]],
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    ispb: ['', [Validators.required, Validators.maxLength(8)]]
  });

  ngOnInit(): void {
    this.loadBancos();
  }

  async loadBancos() {
    this.loading.set(true);
    try {
      this.bancoService.getAll().subscribe(bancos => {
        this.bancos.set(bancos);
      });
    } catch (error) {
      this.showError('Erro ao carregar bancos');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(banco: Banco) {
    this.currentEditId.set(banco.id);
    this.isEditing.set(true);
    this.bancoForm.patchValue({
      codigo: banco.codigo,
      nome: banco.nome,
      ispb: banco.ispb
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.bancoForm.reset();
  }

  async onSubmit() {
    if (this.bancoForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.bancoForm.value;
      
      if (this.isEditing() && this.currentEditId()) {
        await this.bancoService.update(this.currentEditId()!, formData as UpdateBancoDTO);
        this.showSuccess('Banco atualizado com sucesso');
      } else {
        await this.bancoService.create(formData as CreateBancoDTO);
        this.showSuccess('Banco criado com sucesso');
      }

      this.cancelEdit();
      this.loadBancos();
    } catch (error) {
      this.showError('Erro ao salvar banco');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteBanco(id: string) {
    if (confirm('Tem certeza que deseja excluir este banco?')) {
      try {
        await this.bancoService.delete(id);
        this.showSuccess('Banco excluído com sucesso');
        this.loadBancos();
      } catch (error) {
        this.showError('Erro ao excluir banco');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { 
      duration: 3000,
      panelClass: ['success-snackbar']
    });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', {
      duration: 5000,
      panelClass: ['error-snackbar']
    });
  }
}


==================================================
Arquivo: app/pages/cadastros/cliente/cliente.component.html
==================================================

<p>cliente works!</p>
<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-person me-2"></i>
          {{ isEditing() ? 'Editar Cliente' : 'Cadastrar Novo Cliente' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="clienteForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <label class="form-label">Nome</label>
              <input type="text" class="form-control" formControlName="nome" [class.is-invalid]="clienteForm.get('nome')?.invalid && clienteForm.get('nome')?.touched">
              <div class="invalid-feedback">Nome é obrigatório (máx. 100 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">CPF/CNPJ</label>
              <input type="text" class="form-control" formControlName="cpfCnpj" [class.is-invalid]="clienteForm.get('cpfCnpj')?.invalid && clienteForm.get('cpfCnpj')?.touched">
              <div class="invalid-feedback">CPF (11 dígitos) ou CNPJ (14 dígitos) inválido</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Email</label>
              <input type="email" class="form-control" formControlName="email" [class.is-invalid]="clienteForm.get('email')?.invalid && clienteForm.get('email')?.touched">
              <div class="invalid-feedback">Email inválido</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Telefone</label>
              <input type="text" class="form-control" formControlName="telefone" [class.is-invalid]="clienteForm.get('telefone')?.invalid && clienteForm.get('telefone')?.touched">
              <div class="invalid-feedback">Telefone deve ter 10 ou 11 dígitos</div>
            </div>
            <div class="col-md-6">
              <label class="form-label">Endereço</label>
              <input type="text" class="form-control" formControlName="endereco" [class.is-invalid]="clienteForm.get('endereco')?.invalid && clienteForm.get('endereco')?.touched">
              <div class="invalid-feedback">Endereço é obrigatório (máx. 200 caracteres)</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : clienteForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="clienteForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Nome</th>
                <th>CPF/CNPJ</th>
                <th>Email</th>
                <th>Telefone</th>
                <th>Endereço</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let cliente of clientes()">
                <td>{{ cliente.nome }}</td>
                <td>{{ cliente.cpfCnpj }}</td>
                <td>{{ cliente.email }}</td>
                <td>{{ cliente.telefone }}</td>
                <td>{{ cliente.endereco }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(cliente)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteCliente(cliente.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/cliente/cliente.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/cliente/cliente.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { ClienteService } from '../../../service/cadastro/Cliente/Cliente.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Cliente, CreateClienteDTO, UpdateClienteDTO } from '../../../interface/cadastro/Cliente';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-cliente',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './cliente.component.html',
  styleUrls: ['./cliente.component.scss']
})
export class ClienteComponent implements OnInit {
  private clienteService = inject(ClienteService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  clientes = signal<Cliente[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  clienteForm = this.fb.group({
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    cpfCnpj: ['', [Validators.required, Validators.pattern(/^\d{11}|\d{14}$/)]],
    email: ['', [Validators.required, Validators.email]],
    telefone: ['', [Validators.required, Validators.pattern(/^\d{10,11}$/)]],
    endereco: ['', [Validators.required, Validators.maxLength(200)]]
  });

  ngOnInit(): void {
    this.loadClientes();
  }

  async loadClientes() {
    this.loading.set(true);
    try {
      this.clienteService.getAll().subscribe(clientes => {
        this.clientes.set(clientes);
      });
    } catch (error) {
      this.showError('Erro ao carregar clientes');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(cliente: Cliente) {
    this.currentEditId.set(cliente.id);
    this.isEditing.set(true);
    this.clienteForm.patchValue({
      nome: cliente.nome,
      cpfCnpj: cliente.cpfCnpj,
      email: cliente.email,
      telefone: cliente.telefone,
      endereco: cliente.endereco
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.clienteForm.reset();
  }

  async onSubmit() {
    if (this.clienteForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.clienteForm.value;

      if (this.isEditing() && this.currentEditId()) {
        await this.clienteService.update(this.currentEditId()!, formData as UpdateClienteDTO);
        this.showSuccess('Cliente atualizado com sucesso');
      } else {
        await this.clienteService.create(formData as CreateClienteDTO);
        this.showSuccess('Cliente criado com sucesso');
      }

      this.cancelEdit();
      this.loadClientes();
    } catch (error) {
      this.showError('Erro ao salvar cliente');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteCliente(id: string) {
    if (confirm('Tem certeza que deseja excluir este cliente?')) {
      try {
        await this.clienteService.delete(id);
        this.showSuccess('Cliente excluído com sucesso');
        this.loadClientes();
      } catch (error) {
        this.showError('Erro ao excluir cliente');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/cadastros/usuario/usuario.component.html
==================================================

<p>usuario works!</p>



==================================================
Arquivo: app/pages/cadastros/usuario/usuario.component.scss
==================================================




==================================================
Arquivo: app/pages/cadastros/usuario/usuario.component.ts
==================================================

import { Component } from '@angular/core';

@Component({
  selector: 'app-usuario',
  imports: [],
  templateUrl: './usuario.component.html',
  styleUrl: './usuario.component.scss'
})
export class UsuarioComponent {

}



==================================================
Arquivo: app/pages/cadastros/funcionario/funcionario.component.html
==================================================

<p>funcionario works!</p>
<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-person-badge me-2"></i>
          {{ isEditing() ? 'Editar Funcionário' : 'Cadastrar Novo Funcionário' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="funcionarioForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <label class="form-label">Nome</label>
              <input type="text" class="form-control" formControlName="nome" [class.is-invalid]="funcionarioForm.get('nome')?.invalid && funcionarioForm.get('nome')?.touched">
              <div class="invalid-feedback">Nome é obrigatório (máx. 100 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">CPF</label>
              <input type="text" class="form-control" formControlName="cpf" [class.is-invalid]="funcionarioForm.get('cpf')?.invalid && funcionarioForm.get('cpf')?.touched">
              <div class="invalid-feedback">CPF deve ter 11 dígitos</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Email</label>
              <input type="email" class="form-control" formControlName="email" [class.is-invalid]="funcionarioForm.get('email')?.invalid && funcionarioForm.get('email')?.touched">
              <div class="invalid-feedback">Email inválido</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Telefone</label>
              <input type="text" class="form-control" formControlName="telefone" [class.is-invalid]="funcionarioForm.get('telefone')?.invalid && funcionarioForm.get('telefone')?.touched">
              <div class="invalid-feedback">Telefone deve ter 10 ou 11 dígitos</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Cargo</label>
              <input type="text" class="form-control" formControlName="cargo" [class.is-invalid]="funcionarioForm.get('cargo')?.invalid && funcionarioForm.get('cargo')?.touched">
              <div class="invalid-feedback">Cargo é obrigatório (máx. 50 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Data de Admissão</label>
              <input type="date" class="form-control" formControlName="dataAdmissao" [class.is-invalid]="funcionarioForm.get('dataAdmissao')?.invalid && funcionarioForm.get('dataAdmissao')?.touched">
              <div class="invalid-feedback">Data de admissão é obrigatória</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : funcionarioForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="funcionarioForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Nome</th>
                <th>CPF</th>
                <th>Email</th>
                <th>Telefone</th>
                <th>Cargo</th>
                <th>Data de Admissão</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let funcionario of funcionarios()">
                <td>{{ funcionario.nome }}</td>
                <td>{{ funcionario.cpf }}</td>
                <td>{{ funcionario.email }}</td>
                <td>{{ funcionario.telefone }}</td>
                <td>{{ funcionario.cargo }}</td>
                <td>{{ funcionario.dataAdmissao | date:'dd/MM/yyyy' }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(funcionario)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteFuncionario(funcionario.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/funcionario/funcionario.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/funcionario/funcionario.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { FuncionarioService } from '../../../service/cadastro/Funcionario/Funcionario.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Funcionario, CreateFuncionarioDTO, UpdateFuncionarioDTO } from '../../../interface/cadastro/Funcionario';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-funcionario',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './funcionario.component.html',
  styleUrls: ['./funcionario.component.scss']
})
export class FuncionarioComponent implements OnInit {
  private funcionarioService = inject(FuncionarioService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  funcionarios = signal<Funcionario[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  funcionarioForm = this.fb.group({
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    cpf: ['', [Validators.required, Validators.pattern(/^\d{11}$/)]],
    email: ['', [Validators.required, Validators.email]],
    telefone: ['', [Validators.required, Validators.pattern(/^\d{10,11}$/)]],
    cargo: ['', [Validators.required, Validators.maxLength(50)]],
    dataAdmissao: ['', Validators.required]
  });

  ngOnInit(): void {
    this.loadFuncionarios();
  }

  async loadFuncionarios() {
    this.loading.set(true);
    try {
      this.funcionarioService.getAll().subscribe(funcionarios => {
        this.funcionarios.set(funcionarios);
      });
    } catch (error) {
      this.showError('Erro ao carregar funcionários');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(funcionario: Funcionario) {
    this.currentEditId.set(funcionario.id);
    this.isEditing.set(true);
    this.funcionarioForm.patchValue({
      nome: funcionario.nome,
      cpf: funcionario.cpf,
      email: funcionario.email,
      telefone: funcionario.telefone,
      cargo: funcionario.cargo,
      dataAdmissao: new Date(funcionario.dataAdmissao).toISOString().split('T')[0]
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.funcionarioForm.reset();
  }

  async onSubmit() {
    if (this.funcionarioForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.funcionarioForm.value;
      const funcionarioData = {
        ...formData,
        dataAdmissao: new Date(formData.dataAdmissao!)
      };

      if (this.isEditing() && this.currentEditId()) {
        await this.funcionarioService.update(this.currentEditId()!, funcionarioData as UpdateFuncionarioDTO);
        this.showSuccess('Funcionário atualizado com sucesso');
      } else {
        await this.funcionarioService.create(funcionarioData as CreateFuncionarioDTO);
        this.showSuccess('Funcionário criado com sucesso');
      }

      this.cancelEdit();
      this.loadFuncionarios();
    } catch (error) {
      this.showError('Erro ao salvar funcionário');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteFuncionario(id: string) {
    if (confirm('Tem certeza que deseja excluir este funcionário?')) {
      try {
        await this.funcionarioService.delete(id);
        this.showSuccess('Funcionário excluído com sucesso');
        this.loadFuncionarios();
      } catch (error) {
        this.showError('Erro ao excluir funcionário');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/cadastros/conta/conta.component.html
==================================================

<p>conta works!</p>



==================================================
Arquivo: app/pages/cadastros/conta/conta.component.scss
==================================================




==================================================
Arquivo: app/pages/cadastros/conta/conta.component.ts
==================================================

import { Component } from '@angular/core';

@Component({
  selector: 'app-conta',
  imports: [],
  templateUrl: './conta.component.html',
  styleUrl: './conta.component.scss'
})
export class ContaComponent {

}



==================================================
Arquivo: app/pages/cadastros/modulo/modulo-list.component.html
==================================================

<div class="page-container">
  <mat-card class="card-container">
    <mat-card-header>
      <mat-card-title>Gerenciamento de Módulos</mat-card-title>
    </mat-card-header>

    <mat-divider></mat-divider>

    <mat-card-content>
      <!-- Formulário -->
      <form [formGroup]="moduloForm" class="form-container">
        <div class="form-row">
          <mat-form-field appearance="outline">
            <mat-label>Nome do Módulo</mat-label>
            <input matInput formControlName="nome" placeholder="Ex: Gestão Financeira">
            <mat-error *ngIf="moduloForm.get('nome')?.hasError('required')">
              Nome é obrigatório
            </mat-error>
          </mat-form-field>

          <mat-form-field appearance="outline">
            <mat-label>Percentual de Custo</mat-label>
            <input matInput type="number" formControlName="percentualCusto" min="0" max="100">
            <span matTextSuffix>%</span>
            <mat-error *ngIf="moduloForm.get('percentualCusto')?.hasError('required')">
              Percentual é obrigatório
            </mat-error>
          </mat-form-field>
        </div>

        <div class="form-actions">
          <button
            mat-flat-button
            color="primary"
            (click)="saveModulo()"
            [disabled]="moduloForm.invalid || loading()"
          >
            {{ editMode() ? 'Atualizar' : 'Salvar' }}
          </button>

          <button
            *ngIf="editMode()"
            mat-button
            (click)="cancelEdit()"
            [disabled]="loading()"
          >
            Cancelar
          </button>
        </div>
      </form>

      <!-- Barra de pesquisa -->
      <div class="search-container">
        <mat-form-field appearance="outline" class="search-field">
          <mat-label>Pesquisar módulos</mat-label>
          <input matInput [(ngModel)]="searchTerm" placeholder="Digite para filtrar">
          <mat-icon matSuffix>search</mat-icon>
        </mat-form-field>
      </div>

      <!-- Tabela -->
      <div class="table-container">
        <table mat-table [dataSource]="filteredModulos()" class="mat-elevation-z8">
          <!-- Coluna Nome -->
          <ng-container matColumnDef="nome">
            <th mat-header-cell *matHeaderCellDef>Nome</th>
            <td mat-cell *matCellDef="let modulo">{{ modulo.nome }}</td>
          </ng-container>

          <!-- Coluna Percentual -->
          <ng-container matColumnDef="percentualCusto">
            <th mat-header-cell *matHeaderCellDef>% Custo</th>
            <td mat-cell *matCellDef="let modulo">{{ modulo.percentualCusto }}%</td>
          </ng-container>

          <!-- Coluna Ações -->
          <ng-container matColumnDef="actions">
            <th mat-header-cell *matHeaderCellDef>Ações</th>
            <td mat-cell *matCellDef="let modulo">
              <button mat-icon-button color="primary" (click)="startEdit(modulo)">
                <mat-icon>edit</mat-icon>
              </button>
              <button mat-icon-button color="warn" (click)="deleteModulo(modulo.id)">
                <mat-icon>delete</mat-icon>
              </button>
            </td>
          </ng-container>

          <tr mat-header-row *matHeaderRowDef="displayedColumns"></tr>
          <tr mat-row *matRowDef="let row; columns: displayedColumns;"></tr>
        </table>
      </div>
    </mat-card-content>
  </mat-card>
</div>



==================================================
Arquivo: app/pages/cadastros/modulo/modulo-list.component.scss
==================================================

::ng-deep .mat-mdc-text-field-wrapper {
  width: 100%;
  z-index: 0;
  background-color: lightgray;
  color:black;



  height: 30px;
  border-radius: 5px;
  align-items: center;
}

::ng-deep .mat-mdc-card-title, .mat-mdc-card-subtitle {
  display: block;
  margin: 0;
  color: var(--primary-color);
}

.page-container {
  border-radius: 10px;
  padding: 0.5rem;
  height: 100%;
  background-color: darkgray;
  color: var(--text-color);
  display: flex;
  justify-content: center;
  align-items: center;
}

.card-container {
  background-color: lightgray;
  color: var(--text-color);
  border: 1px solid var(--border-color);
  height: 100%;
  display: flex;
  flex-direction: column;
  width: 100%;
  max-width: 800px; /* Reduzir a largura máxima */
}

.form-container {
  padding: 0.5rem;
  display: flex;
  flex-direction: column;
  gap: 0.5rem;
}

.form-row {
  display: flex;
  gap: 0.5rem;

  mat-form-field {
    flex: 1;
  }
}

.form-actions {
  display: flex;
  gap: 0.5rem;
  justify-content: flex-end;
  margin-top: 0.5rem;
}

.search-container {
  padding: 0 0.5rem;
}

.table-container {
  padding: 0.5rem;
  flex: 1;
  overflow: auto;
  margin-top: 0.5rem;
  max-height: 53%; /* Reduzir a altura máxima do container da tabela */
  overflow-y: auto; /* Adiciona rolagem vertical */

  table {
    width: 100%;
    background-color: var(--sidebar-color);

    th, td {
      color: var(--text-color);
      border-bottom-color: var(--border-color);
    }

    tr:hover {
      background-color: rgba(255, 255, 255, 0.05);
    }
  }
}

mat-form-field {
  --mdc-filled-text-field-container-color: #{var(--sidebar-color)};
  --mdc-filled-text-field-active-indicator-color: #{var(--primary-color)};
  --mdc-filled-text-field-focus-active-indicator-color: #{var(--primary-color)};
  --mdc-filled-text-field-label-text-color: #{var(--text-color)};
  --mdc-filled-text-field-input-text-color: #{var(--text-color)};
}

.mat-mdc-card {
  --mdc-elevated-card-container-color: #{var(--sidebar-color)};
}

.mat-mdc-button {
  --mdc-text-button-label-text-color: #{var(--text-color)};
}

.mat-mdc-flat-button {
  --mdc-filled-button-container-color: #{var(--primary-color)};
  --mdc-filled-button-label-text-color: white;
}

.mat-table {
  width: 100%;
  height: 100%;
}



==================================================
Arquivo: app/pages/cadastros/modulo/modulo-list.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { ModuloListComponent } from './modulo-list.component';

describe('ModuloListComponent', () => {
  let component: ModuloListComponent;
  let fixture: ComponentFixture<ModuloListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [ModuloListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(ModuloListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/pages/cadastros/modulo/modulo-list.component.ts
==================================================

import { Component, inject, signal, computed } from '@angular/core';
import { CommonModule } from '@angular/common';
import { ModuloService } from '../../../service/cadastro/modulo/Modulo.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatCardModule } from '@angular/material/card';
import { MatTableModule } from '@angular/material/table';
import { MatButtonModule } from '@angular/material/button';
import { MatIconModule } from '@angular/material/icon';
import { MatInputModule } from '@angular/material/input';
import { MatFormFieldModule } from '@angular/material/form-field';
import { MatDividerModule } from '@angular/material/divider';
import { MatSnackBar } from '@angular/material/snack-bar';
import { FormsModule } from '@angular/forms';
import { firstValueFrom } from 'rxjs';

@Component({
  selector: 'app-modulo-page',
  standalone: true,
  imports: [
    CommonModule,
    ReactiveFormsModule,
    MatCardModule,
    MatTableModule,
    MatButtonModule,
    MatIconModule,
    MatInputModule,
    MatFormFieldModule,
    MatDividerModule,
    FormsModule
  ],
  templateUrl: './modulo-list.component.html',
  styleUrls: ['./modulo-list.component.scss']
})
export class ModuloListComponent {
  isEditMode: boolean = false;
  private moduloService = inject(ModuloService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  // Estado da aplicação
  modulos = signal<any[]>([]);
  loading = signal(false);
  searchTerm = signal('');
  editMode = signal(false);
  currentId = signal<number | null>(null);

  // Formulário reativo
  moduloForm = this.fb.group({
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    percentualCusto: [0, [Validators.required, Validators.min(0), Validators.max(100)]]
  });

  // Colunas da tabela
  displayedColumns: string[] = ['nome', 'percentualCusto', 'actions'];

  // Filtro computado
  filteredModulos = computed(() => {
    const term = this.searchTerm().toLowerCase();
    return this.modulos().filter(modulo =>
      modulo.nome.toLowerCase().includes(term)
    );
  });

  constructor() {
    this.loadModulos();
  }

  async loadModulos() {
    this.loading.set(true);
    try {
      const modulos = await firstValueFrom(this.moduloService.getAll());
      this.modulos.set(modulos || []);
    } catch (error) {
      this.showError('Erro ao carregar módulos');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(modulo: any) {
    this.currentId.set(modulo.id);
    this.editMode.set(true);
    this.moduloForm.patchValue(modulo);
  }

  cancelEdit() {
    this.editMode.set(false);
    this.currentId.set(null);
    this.moduloForm.reset();
  }

  async saveModulo() {
    if (this.moduloForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.moduloForm.value;

      if (this.editMode()) {
        await firstValueFrom(this.moduloService.update(this.currentId()!, {
          ...formData,
          nome: formData.nome || '',
          percentualCusto: formData.percentualCusto ?? 0 // Garantir que percentualCusto não seja null
        }));
        this.showSuccess('Módulo atualizado com sucesso');
      } else {
        await firstValueFrom(this.moduloService.create({
          nome: formData.nome || '',
          percentualCusto: formData.percentualCusto ?? 0 // Garantir que percentualCusto não seja null
        }));
        this.showSuccess('Módulo criado com sucesso');
      }

      this.cancelEdit();
      this.loadModulos();
    } catch (error) {
      this.showError('Erro ao salvar módulo');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteModulo(id: number) {
    if (confirm('Tem certeza que deseja excluir este módulo?')) {
      try {
        await firstValueFrom(this.moduloService.delete(id));
        this.showSuccess('Módulo excluído com sucesso');
        this.loadModulos();
      } catch (error) {
        this.showError('Erro ao excluir módulo');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000 });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', {
      duration: 5000,
      panelClass: ['error-snackbar']
    });
  }
}



==================================================
Arquivo: app/pages/cadastros/plano/plano-list.component.html
==================================================

<app-page-container title="Planos" [loading]="loading()">
  <app-search-toolbar
    (searchChange)="handleSearch($event)"
    (addClick)="openFormDialog()"
  ></app-search-toolbar>

  <app-data-table
    [dataSource]="filteredPlanos()"
    [columns]="columns"
    [loading]="loading()"
    (edit)="openFormDialog($event)"
    (delete)="deletePlano($event)"
  ></app-data-table>
</app-page-container>



==================================================
Arquivo: app/pages/cadastros/plano/plano-list.component.scss
==================================================




==================================================
Arquivo: app/pages/cadastros/plano/plano-list.component.spec.ts
==================================================

import { ComponentFixture, TestBed } from '@angular/core/testing';

import { PlanoListComponent } from './plano-list.component';

describe('PlanoListComponent', () => {
  let component: PlanoListComponent;
  let fixture: ComponentFixture<PlanoListComponent>;

  beforeEach(async () => {
    await TestBed.configureTestingModule({
      imports: [PlanoListComponent]
    })
    .compileComponents();

    fixture = TestBed.createComponent(PlanoListComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
  });

  it('should create', () => {
    expect(component).toBeTruthy();
  });
});



==================================================
Arquivo: app/pages/cadastros/plano/plano-list.component.ts
==================================================

import { Component, computed, inject, signal } from '@angular/core';
import { CommonModule } from '@angular/common';
import { MatDialog } from '@angular/material/dialog';
import { PlanoService } from '../../../service/cadastro/plano/Plano.service';
import { TableColumn } from '../../../components/data-table/data-table.component';
import { PlanoFormDialogComponent } from '../../../components/plano-form-dialog/plano-form-dialog.component';
import { PageContainerComponent } from '../../../components/page-container/page-container.component';
import { SearchToolbarComponent } from '../../../components/search-toolbar/search-toolbar.component';
import { DataTableComponent } from '../../../components/data-table/data-table.component';


@Component({
  selector: 'app-plano-list',
  standalone: true,
  imports: [CommonModule, PageContainerComponent, SearchToolbarComponent, DataTableComponent],
  templateUrl: './plano-list.component.html'
})
export class PlanoListComponent {
  private planoService = inject(PlanoService);
  private dialog = inject(MatDialog);

  planos = signal<any[]>([]);
  loading = signal(false);
  searchTerm = signal('');

  columns: TableColumn[] = [
    { key: 'id', header: 'ID', type: 'text' },
    { key: 'nome', header: 'Nome', type: 'text' },
    { key: 'precoBasePorLoja', header: 'Preço Base', type: 'currency' },
    { key: 'gratuito', header: 'Gratuito', type: 'boolean' }
  ];

  filteredPlanos = computed(() => {
    const term = this.searchTerm().toLowerCase();
    return this.planos().filter(plano =>
      plano.nome.toLowerCase().includes(term) ||
      plano.precoBasePorLoja.toString().includes(term)
    );
  });

  constructor() {
    this.loadPlanos();
  }

  async loadPlanos() {
    this.loading.set(true);
    try {
      this.planoService.getAll().subscribe(planos => {
        this.planos.set(planos);
      });
    } catch (error) {
      console.error('Erro ao carregar planos:', error);
    } finally {
      this.loading.set(false);
    }
  }

  handleSearch(term: string) {
    this.searchTerm.set(term);
  }

  openFormDialog(plano?: any) {
    const dialogRef = this.dialog.open(PlanoFormDialogComponent, {
      width: '600px',
      data: plano ? { ...plano } : null
    });

    dialogRef.afterClosed().subscribe(result => {
      if (result) this.loadPlanos();
    });
  }

  async deletePlano(plano: any) {
    if (confirm(`Tem certeza que deseja excluir o plano ${plano.nome}?`)) {
      await this.planoService.delete(plano.id);
      this.loadPlanos();
    }
  }
}



==================================================
Arquivo: app/pages/cadastros/produto/produto.component.html
==================================================

<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-box-seam me-2"></i>
          {{ isEditing() ? 'Editar Produto' : 'Cadastrar Novo Produto' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="produtoForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <label class="form-label">Nome</label>
              <input type="text" class="form-control" formControlName="nome" [class.is-invalid]="produtoForm.get('nome')?.invalid && produtoForm.get('nome')?.touched">
              <div class="invalid-feedback">Nome é obrigatório (máx. 100 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Código</label>
              <input type="text" class="form-control" formControlName="codigo" [class.is-invalid]="produtoForm.get('codigo')?.invalid && produtoForm.get('codigo')?.touched">
              <div class="invalid-feedback">Código é obrigatório (máx. 50 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Preço</label>
              <input type="number" class="form-control" formControlName="preco" step="0.01" [class.is-invalid]="produtoForm.get('preco')?.invalid && produtoForm.get('preco')?.touched">
              <div class="invalid-feedback">Preço deve ser maior ou igual a 0</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Estoque</label>
              <input type="number" class="form-control" formControlName="estoque" [class.is-invalid]="produtoForm.get('estoque')?.invalid && produtoForm.get('estoque')?.touched">
              <div class="invalid-feedback">Estoque deve ser maior ou igual a 0</div>
            </div>
            <div class="col-md-9">
              <label class="form-label">Descrição</label>
              <textarea class="form-control" formControlName="descricao" rows="3" [class.is-invalid]="produtoForm.get('descricao')?.invalid && produtoForm.get('descricao')?.touched"></textarea>
              <div class="invalid-feedback">Descrição deve ter no máximo 500 caracteres</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : produtoForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="produtoForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Nome</th>
                <th>Código</th>
                <th>Preço</th>
                <th>Estoque</th>
                <th>Descrição</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let produto of produtos()">
                <td>{{ produto.nome }}</td>
                <td>{{ produto.codigo }}</td>
                <td>{{ produto.preco | currency:'BRL' }}</td>
                <td>{{ produto.estoque }}</td>
                <td>{{ produto.descricao || '-' }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(produto)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteProduto(produto.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/produto/produto.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control,
    textarea {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/produto/produto.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { ProdutoService } from '../../../service/cadastro/produto/Produto.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Produto, CreateProdutoDTO, UpdateProdutoDTO } from '../../../interface/cadastro/Produto';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-produto',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './produto.component.html',
  styleUrls: ['./produto.component.scss']
})
export class ProdutoComponent implements OnInit {
  private produtoService = inject(ProdutoService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  produtos = signal<Produto[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  produtoForm = this.fb.group({
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    codigo: ['', [Validators.required, Validators.maxLength(50)]],
    preco: [0, [Validators.required, Validators.min(0)]],
    estoque: [0, [Validators.required, Validators.min(0)]],
    descricao: ['', Validators.maxLength(500)]
  });

  ngOnInit(): void {
    this.loadProdutos();
  }

  async loadProdutos() {
    this.loading.set(true);
    try {
      this.produtoService.getAll().subscribe(produtos => {
        this.produtos.set(produtos);
      });
    } catch (error) {
      this.showError('Erro ao carregar produtos');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(produto: Produto) {
    this.currentEditId.set(produto.id);
    this.isEditing.set(true);
    this.produtoForm.patchValue({
      nome: produto.nome,
      codigo: produto.codigo,
      preco: produto.preco,
      estoque: produto.estoque,
      descricao: produto.descricao || ''
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.produtoForm.reset();
  }

  async onSubmit() {
    if (this.produtoForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.produtoForm.value;

      if (this.isEditing() && this.currentEditId()) {
        await this.produtoService.update(this.currentEditId()!, formData as UpdateProdutoDTO);
        this.showSuccess('Produto atualizado com sucesso');
      } else {
        await this.produtoService.create(formData as CreateProdutoDTO);
        this.showSuccess('Produto criado com sucesso');
      }

      this.cancelEdit();
      this.loadProdutos();
    } catch (error) {
      this.showError('Erro ao salvar produto');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteProduto(id: string) {
    if (confirm('Tem certeza que deseja excluir este produto?')) {
      try {
        await this.produtoService.delete(id);
        this.showSuccess('Produto excluído com sucesso');
        this.loadProdutos();
      } catch (error) {
        this.showError('Erro ao excluir produto');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/cadastros/loja/loja.component.html
==================================================

<div class="container-fluid mt-3">
    <div class="card">
      <div class="card-header">
        <h5 class="mb-0">
          <i class="bi bi-shop me-2"></i>
          {{ isEditing() ? 'Editar Loja' : 'Cadastrar Nova Loja' }}
        </h5>
      </div>
      
      <div class="card-body">
        <form [formGroup]="lojaForm" (ngSubmit)="onSubmit()">
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <label class="form-label">Nome</label>
              <input type="text" class="form-control" formControlName="nome" [class.is-invalid]="lojaForm.get('nome')?.invalid && lojaForm.get('nome')?.touched">
              <div class="invalid-feedback">Nome é obrigatório (máx. 100 caracteres)</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">CNPJ</label>
              <input type="text" class="form-control" formControlName="cnpj" [class.is-invalid]="lojaForm.get('cnpj')?.invalid && lojaForm.get('cnpj')?.touched">
              <div class="invalid-feedback">CNPJ deve ter 14 dígitos</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Email</label>
              <input type="email" class="form-control" formControlName="email" [class.is-invalid]="lojaForm.get('email')?.invalid && lojaForm.get('email')?.touched">
              <div class="invalid-feedback">Email inválido</div>
            </div>
            <div class="col-md-3">
              <label class="form-label">Telefone</label>
              <input type="text" class="form-control" formControlName="telefone" [class.is-invalid]="lojaForm.get('telefone')?.invalid && lojaForm.get('telefone')?.touched">
              <div class="invalid-feedback">Telefone deve ter 10 ou 11 dígitos</div>
            </div>
            <div class="col-md-6">
              <label class="form-label">Endereço</label>
              <input type="text" class="form-control" formControlName="endereco" [class.is-invalid]="lojaForm.get('endereco')?.invalid && lojaForm.get('endereco')?.touched">
              <div class="invalid-feedback">Endereço é obrigatório (máx. 200 caracteres)</div>
            </div>
          </div>
          <div class="d-flex justify-content-end gap-2">
            <button type="button" class="btn btn-outline-secondary" (click)="isEditing() ? cancelEdit() : lojaForm.reset()">
              <i class="bi bi-x-circle me-1"></i>
              {{ isEditing() ? 'Cancelar' : 'Limpar' }}
            </button>
            <button type="submit" class="btn btn-primary" [disabled]="lojaForm.invalid || loading()">
              <span *ngIf="loading()" class="spinner-border spinner-border-sm me-1"></span>
              <i *ngIf="!loading()" class="bi bi-save me-1"></i>
              {{ isEditing() ? 'Atualizar' : 'Salvar' }}
            </button>
          </div>
        </form>
  
        <div class="mt-4 table-responsive">
          <table class="table table-hover">
            <thead>
              <tr>
                <th>Nome</th>
                <th>CNPJ</th>
                <th>Email</th>
                <th>Telefone</th>
                <th>Endereço</th>
                <th class="text-end">Ações</th>
              </tr>
            </thead>
            <tbody>
              <tr *ngFor="let loja of lojas()">
                <td>{{ loja.nome }}</td>
                <td>{{ loja.cnpj }}</td>
                <td>{{ loja.email }}</td>
                <td>{{ loja.telefone }}</td>
                <td>{{ loja.endereco }}</td>
                <td class="text-end">
                  <div class="btn-group btn-group-sm">
                    <button class="btn btn-outline-primary" (click)="startEdit(loja)" [disabled]="loading()">
                      <i class="bi bi-pencil"></i>
                    </button>
                    <button class="btn btn-outline-danger" (click)="deleteLoja(loja.id)" [disabled]="loading()">
                      <i class="bi bi-trash"></i>
                    </button>
                  </div>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
  </div>


==================================================
Arquivo: app/pages/cadastros/loja/loja.component.scss
==================================================

:host {
    .card {
      background-color: var(--sidebar-color);
      border-color: var(--border-color);
      color: var(--text-color);
      &-header {
        background-color: var(--header-color) !important;
        border-bottom-color: var(--border-color);
      }
    }
    .table {
      --bs-table-bg: var(--sidebar-color);
      --bs-table-color: var(--text-color);
      --bs-table-border-color: var(--border-color);
      --bs-table-striped-bg: #{rgba(var(--primary-blue), 0.05)};
      --bs-table-hover-bg: #{rgba(var(--primary-blue), 0.15)};
      th {
        background-color: var(--header-color);
      }
    }
    .form-control {
      background-color: var(--input-bg);
      color: var(--text-color);
      border-color: var(--border-color);
      &:focus {
        border-color: var(--primary-blue);
        box-shadow: 0 0 0 0.25rem rgba(var(--primary-blue), 0.25);
      }
    }
    .btn-outline-primary {
      --bs-btn-color: var(--primary-blue);
      --bs-btn-border-color: var(--primary-blue);
      --bs-btn-hover-bg: var(--primary-blue);
    }
    .btn-outline-danger {
      --bs-btn-color: var(--error-color);
      --bs-btn-border-color: var(--error-color);
      --bs-btn-hover-bg: var(--error-color);
    }
    .invalid-feedback {
      color: var(--error-color);
    }
    .is-invalid {
      border-color: var(--error-color) !important;
    }
  }
  .spinner-border {
    vertical-align: middle;
  }


==================================================
Arquivo: app/pages/cadastros/loja/loja.component.ts
==================================================

import { Component, OnInit, inject, signal } from '@angular/core';
import { LojaService } from '../../../service/cadastro/loja/Loja.service';
import { FormBuilder, ReactiveFormsModule, Validators } from '@angular/forms';
import { MatSnackBar } from '@angular/material/snack-bar';
import { Loja, CreateLojaDTO, UpdateLojaDTO } from '../../../interface/cadastro/Loja';
import { CommonModule } from '@angular/common';

@Component({
  selector: 'app-loja',
  standalone: true,
  imports: [CommonModule, ReactiveFormsModule],
  templateUrl: './loja.component.html',
  styleUrls: ['./loja.component.scss']
})
export class LojaComponent implements OnInit {
  private lojaService = inject(LojaService);
  private fb = inject(FormBuilder);
  private snackBar = inject(MatSnackBar);

  lojas = signal<Loja[]>([]);
  loading = signal(false);
  isEditing = signal(false);
  currentEditId = signal<string | null>(null);

  lojaForm = this.fb.group({
    nome: ['', [Validators.required, Validators.maxLength(100)]],
    cnpj: ['', [Validators.required, Validators.pattern(/^\d{14}$/)]],
    email: ['', [Validators.required, Validators.email]],
    telefone: ['', [Validators.required, Validators.pattern(/^\d{10,11}$/)]],
    endereco: ['', [Validators.required, Validators.maxLength(200)]]
  });

  ngOnInit(): void {
    this.loadLojas();
  }

  async loadLojas() {
    this.loading.set(true);
    try {
      this.lojaService.getAll().subscribe(lojas => {
        this.lojas.set(lojas);
      });
    } catch (error) {
      this.showError('Erro ao carregar lojas');
    } finally {
      this.loading.set(false);
    }
  }

  startEdit(loja: Loja) {
    this.currentEditId.set(loja.id);
    this.isEditing.set(true);
    this.lojaForm.patchValue({
      nome: loja.nome,
      cnpj: loja.cnpj,
      email: loja.email,
      telefone: loja.telefone,
      endereco: loja.endereco
    });
  }

  cancelEdit() {
    this.currentEditId.set(null);
    this.isEditing.set(false);
    this.lojaForm.reset();
  }

  async onSubmit() {
    if (this.lojaForm.invalid) return;

    this.loading.set(true);
    try {
      const formData = this.lojaForm.value;

      if (this.isEditing() && this.currentEditId()) {
        await this.lojaService.update(this.currentEditId()!, formData as UpdateLojaDTO);
        this.showSuccess('Loja atualizada com sucesso');
      } else {
        await this.lojaService.create(formData as CreateLojaDTO);
        this.showSuccess('Loja criada com sucesso');
      }

      this.cancelEdit();
      this.loadLojas();
    } catch (error) {
      this.showError('Erro ao salvar loja');
    } finally {
      this.loading.set(false);
    }
  }

  async deleteLoja(id: string) {
    if (confirm('Tem certeza que deseja excluir esta loja?')) {
      try {
        await this.lojaService.delete(id);
        this.showSuccess('Loja excluída com sucesso');
        this.loadLojas();
      } catch (error) {
        this.showError('Erro ao excluir loja');
      }
    }
  }

  private showSuccess(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 3000, panelClass: ['success-snackbar'] });
  }

  private showError(message: string) {
    this.snackBar.open(message, 'Fechar', { duration: 5000, panelClass: ['error-snackbar'] });
  }
}


==================================================
Arquivo: app/pages/login/login.component.html
==================================================

<div class="login-container">
  <div class="login-box">
    <h2>Login</h2>
    <form [formGroup]="loginForm" (ngSubmit)="onSubmit()">
      <div class="form-group">
        <label for="email">Email:</label>
        <input
          type="email"
          id="email"
          formControlName="email"
          placeholder="Digite seu email"
          class="form-control"
        />
        @if (loginForm.get('email')?.invalid && loginForm.get('email')?.touched) {
          <div class="error-message">Email inválido</div>
        }
      </div>

      <div class="form-group">
        <label for="password">Senha:</label>
        <input
          type="password"
          id="password"
          formControlName="password"
          placeholder="Digite sua senha"
          class="form-control"
        />
      </div>

      <button type="submit" [disabled]="!loginForm.valid" class="btn-login">
        Login
      </button>
    </form>
    <p class="forgot-password">
      <a href="#">Esqueceu sua senha?</a>
    </p>
  </div>
</div>


==================================================
Arquivo: app/pages/login/login.component.scss
==================================================


.login-container {
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100%;
  width: 100%;
  background-image: url('../../../assets/imagens/senha.jpg');
  background-size: cover;
  background-position: center;
  background-repeat: no-repeat;
  position: relative;

  // Adiciona uma camada de overlay para escurecer o fundo e destacar o formulário
  &::before {
    content: '';
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: rgba(0, 0, 0, 0.6); // Overlay escuro
    z-index: 1;
  }
}

.login-box {
  position: relative;
  z-index: 2;
  background: var(--background-dark);
  padding: 2rem;
  border-radius: 8px;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.5);
  width: 100%;
  max-width: 400px;
  text-align: center;

  h2 {
    color: var(--text-light);
    margin-bottom: 1.5rem;
    font-size: 1.8rem;
    font-weight: 500;
  }

  .form-group {
    margin-bottom: 1.5rem;
    text-align: left;

    label {
      color: var(--text-light);
      font-size: 0.9rem;
      margin-bottom: 0.5rem;
      display: block;
    }

    .form-control {
      width: 100%;
      padding: 0.75rem;
      background: var(--input-bg);
      border: 1px solid var(--border-color);
      border-radius: 4px;
      color: var(--text-light);
      font-size: 1rem;
      transition: border-color 0.3s ease;

      &:focus {
        outline: none;
        border-color: var(--primary-blue);
        box-shadow: 0 0 5px rgba(var(--primary-blue), 0.3);
      }

      &::placeholder {
        color: #858585;
      }
    }

    .error-message {
      color: var(--error-color);
      font-size: 0.85rem;
      margin-top: 0.3rem;
    }
  }

  .btn-login {
    width: 100%;
    padding: 0.75rem;
    background: var(--primary-blue);
    border: none;
    border-radius: 4px;
    color: var(--text-light);
    font-size: 1rem;
    font-weight: 500;
    cursor: pointer;
    transition: 0.3s ease;

    &:hover {
      background: darken(blue, 10%);
    }

    &:disabled {
      background: #555;
      cursor: not-allowed;
    }
  }

  .forgot-password {
    margin-top: 1rem;

    a {
      color: var(--accent-orange);
      text-decoration: none;
      font-size: 0.9rem;

      &:hover {
        text-decoration: underline;
      }
    }
  }
}


==================================================
Arquivo: app/pages/login/login.component.ts
==================================================

import { Component } from '@angular/core';
import { ReactiveFormsModule, FormBuilder, Validators } from '@angular/forms';
import { AuthService } from '../../service/login/AuthService.service';
import { Router } from '@angular/router';
import { CommonModule } from '@angular/common';
import { LoginRequest } from '../../interface/Login';

@Component({
  standalone: true,
  imports: [ReactiveFormsModule, CommonModule],
  templateUrl: './login.component.html',
  styleUrls: ['./login.component.scss']
})
export class LoginComponent {
  loginForm;

  constructor(
    private fb: FormBuilder,
    private authService: AuthService,
    private router: Router
  ) {
    this.loginForm = this.fb.group({
      email: ['', [Validators.required, Validators.email]],
      password: ['', Validators.required]
    });
  }

  onSubmit(): void {
    if (this.loginForm.valid) {
      console.log('Form submitted:', this.loginForm.value); // Para depuração
      this.authService.login(this.loginForm.value as LoginRequest).subscribe({
        next: () => {
          console.log('Login successful, redirecting...');
          this.router.navigate(['/app.component']);
        },
        error: (err) => {
          console.error('Login failed:', err);
          // Aqui você pode adicionar um feedback visual para o usuário, como uma mensagem de erro
        }
      });
    } else {
      console.log('Form is invalid');
    }
  }
}

==================================================
Resumo:
Total de arquivos processados: 128
Arquivos com erro: 0
Arquivos processados com sucesso: 128
==================================================
